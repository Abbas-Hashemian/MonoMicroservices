<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DryIoc</name>
    </assembly>
    <members>
        <member name="T:DryIoc.Container">
            <summary>Inversion of control container</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor">
            <summary>Creates new container with default rules <see cref="F:DryIoc.Rules.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor(DryIoc.Rules,DryIoc.IScopeContext)">
            <summary>Creates new container, optionally providing <see cref="P:DryIoc.Container.Rules"/> to modify default container behavior.</summary>
            <param name="rules">(optional) Rules to modify container default resolution behavior.
            If not specified, then <see cref="F:DryIoc.Rules.Default"/> will be used.</param>
            <param name="scopeContext">(optional) Scope context to use for scoped reuse.</param>
        </member>
        <member name="M:DryIoc.Container.#ctor(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Creates new container with configured rules.</summary>
            <param name="configure">Allows to modify <see cref="F:DryIoc.Rules.Default"/> rules.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</param>
        </member>
        <member name="M:DryIoc.Container.NewSingletonScope">
            <summary>Helper to create singleton scope</summary>
        </member>
        <member name="M:DryIoc.Container.ToString">
            <summary>Pretty prints the container info including the open scope details if any.</summary> 
        </member>
        <member name="M:DryIoc.Container.Dispose">
            <summary>Dispose either open scope, or container with singletons, if no scope opened.</summary>
        </member>
        <member name="T:DryIoc.Container.ResolveManyResult">
            <summary>Identifies the service when resolving collection</summary>
        </member>
        <member name="F:DryIoc.Container.ResolveManyResult.FactoryDelegate">
            <summary>Factory, the required part</summary>
        </member>
        <member name="F:DryIoc.Container.ResolveManyResult.ServiceKey">
            <summary>Optional key</summary>
        </member>
        <member name="F:DryIoc.Container.ResolveManyResult.RequiredServiceType">
            <summary>Optional required service type, can be an open-generic type.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveManyResult.Of(DryIoc.FactoryDelegate,System.Object,System.Type)">
            <summary>Constructs the struct.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveCompileTimeGeneratedOrDefault(System.Type)">
            <summary>Directly uses generated factories to resolve service. Or returns the default if service does not have generated factory.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveCompileTimeGeneratedOrDefault(System.Type,System.Object)">
            <summary>Directly uses generated factories to resolve service. Or returns the default if service does not have generated factory.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveManyCompileTimeGeneratedOrEmpty(System.Type)">
            <summary>Resolves many generated only services. Ignores runtime registrations.</summary>
        </member>
        <member name="M:DryIoc.Container.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.Container.GetRegisteredFactories(System.Type,System.Object,DryIoc.FactoryType)">
            <summary>Searches for registered factories by type, and key (if specified),
            and by factory type (by default uses <see cref="F:DryIoc.FactoryType.Service"/>).
            May return empty, 1 or multiple factories.</summary>
        </member>
        <member name="M:DryIoc.Container.Register(DryIoc.Factory,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean)">
            <summary>Stores factory into container using <paramref name="serviceType"/> and <paramref name="serviceKey"/> as key
            for later lookup.</summary>
            <param name="factory">Any subtypes of <see cref="T:DryIoc.Factory"/>.</param>
            <param name="serviceType">Type of service to resolve later.</param>
            <param name="serviceKey">(optional) Service key of any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>
            implemented.</param>
            <param name="ifAlreadyRegistered">(optional) Says how to handle existing registration with the same
            <paramref name="serviceType"/> and <paramref name="serviceKey"/>.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.Container.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.System#IServiceProvider#GetService(System.Type)">
            <summary>
            Resolves service with the <see cref="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered"/> policy,
            enabling the fallback resolution for not registered services (default MS convention).
            For diagnostics reasons, you may globally set the rule <see cref="P:DryIoc.Rules.ServiceProviderGetServiceShouldThrowIfUnresolved"/> to alter the behavior. 
            It may help to highlight the issues by throwing the original rich <see cref="T:DryIoc.ContainerException"/> instead of just returning the `null`.
            </summary>
        </member>
        <member name="P:DryIoc.Container.Parent">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.Root">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.SingletonScope">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.ScopeContext">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.CurrentScope">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.CurrentOrSingletonScope">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.WithCurrentScope(DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.Use(System.Type,System.Object)">
            <summary>Setting the factory directly to scope for resolution</summary> 
        </member>
        <member name="P:DryIoc.Container.Rules">
            <summary>The rules object defines policies per container for registration and resolution.</summary>
        </member>
        <member name="P:DryIoc.Container.OwnCurrentScope">
            <summary>Represents scope bound to container itself, and not the ambient (context) thing.</summary>
        </member>
        <member name="P:DryIoc.Container.IsDisposed">
            <summary>Indicates that container is disposed.</summary>
        </member>
        <member name="P:DryIoc.Container.DisposeInfo">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope,System.Nullable{DryIoc.IsRegistryChangePermitted})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional) Controls what to do with the next registration: ignore or throw exception. Throws exception by default.</param>
        </member>
        <member name="M:DryIoc.Container.ClearCache(System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.GetConstantExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known item into literal expression or wraps it in a constant expression.</summary>
        </member>
        <member name="P:DryIoc.Container.Registry.FactoryExpressionCache">
            <summary>The int key is the `FactoryID`</summary>
        </member>
        <member name="T:DryIoc.OpenGenericTypeKey">
            Special service key with info about open-generic service type
        </member>
        <member name="F:DryIoc.OpenGenericTypeKey.RequiredServiceType">
            <summary>Open-generic required service-type</summary>
        </member>
        <member name="F:DryIoc.OpenGenericTypeKey.ServiceKey">
            <summary>Optional key</summary>
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.#ctor(System.Type,System.Object)">
            <summary>Constructs the thing</summary>
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.ToString">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.ToExpression(System.Func{System.Object,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.HiddenDisposable">
            <summary>Hides/wraps object with disposable interface.</summary> 
        </member>
        <member name="F:DryIoc.HiddenDisposable.Value">
            <summary>Wrapped value</summary>
        </member>
        <member name="M:DryIoc.HiddenDisposable.#ctor(System.Object)">
            <summary>Wraps the value</summary>
        </member>
        <member name="T:DryIoc.Interpreter">
            <summary>Interpreter of expression - where possible uses knowledge of DryIoc internals to avoid reflection</summary>
        </member>
        <member name="M:DryIoc.Interpreter.TryInterpretAndUnwrapContainerException(DryIoc.IResolverContext,DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Object@)">
            <summary>Calls `TryInterpret` inside try-catch and unwraps/re-throws `ContainerException` from the reflection `TargetInvocationException`</summary>
        </member>
        <member name="T:DryIoc.Interpreter.ParentLambdaArgs">
            <summary>Stores parent lambda params and args</summary>
        </member>
        <member name="F:DryIoc.Interpreter.ParentLambdaArgs.ParentWithArgs">
            <summary> Parent or the `null` for the root </summary>
        </member>
        <member name="F:DryIoc.Interpreter.ParentLambdaArgs.ParamExprs">
            <summary> Params </summary>
        </member>
        <member name="F:DryIoc.Interpreter.ParentLambdaArgs.ParamValues">
            <summary> A single arg or the array of object args </summary>
        </member>
        <member name="M:DryIoc.Interpreter.ParentLambdaArgs.#ctor(DryIoc.Interpreter.ParentLambdaArgs,DryIoc.FastExpressionCompiler.LightExpression.IParameterProvider,System.Object)">
            <summary>Constructs with parent parent or `null` for the root</summary>
        </member>
        <member name="M:DryIoc.Interpreter.TryInterpret(DryIoc.IResolverContext,DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.IParameterProvider,System.Object,DryIoc.Interpreter.ParentLambdaArgs,System.Object@)">
            <summary>Interprets passed expression.</summary>
        </member>
        <member name="T:DryIoc.FactoryDelegateCompiler">
            <summary>Compiles expression to factory delegate.</summary>
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.ResolverContextParamExpr">
            <summary>Resolver context parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.ResolverContextParamExprs">
            <summary>The array of a single `ResolverContextParamExpr` for memory optimization</summary>
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.InvokeMethod">
            <summary>FactoryDelegate.Invoke method info for calling from Reflection</summary>
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.FactoryDelegateParamExprs">
            Optimization: the empty lambda with a single IResolverContext parameters
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.NormalizeExpression(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Strips the unnecessary or adds the necessary cast to expression return result</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.WrapInFactoryExpression(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Wraps service creation expression (body) into <see cref="T:DryIoc.FactoryDelegate"/> and returns result lambda expression.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.WrapInFactoryExpressionWithoutNormalization(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Wraps service creation expression (body) into <see cref="T:DryIoc.FactoryDelegate"/> and returns result lambda expression.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Boolean)">
            <summary>First wraps the input service expression into lambda expression and
            then compiles lambda expression to actual <see cref="T:DryIoc.FactoryDelegate"/> used for service resolution.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type,System.Type,System.Boolean)">
            <summary>Compiles lambda expression to actual `FactoryDelegate` wrapper.</summary>
        </member>
        <member name="T:DryIoc.ContainerTools">
            <summary>Container extended features.</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.FacadeKey">
            <summary>The default key for services registered into container created by <see cref="M:DryIoc.ContainerTools.CreateFacade(DryIoc.IContainer,System.String)"/></summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithFacadeRules(DryIoc.Rules,System.String)">
            <summary>Uses the provided or the default <see cref="F:DryIoc.ContainerTools.FacadeKey" /> to tweak the rules
            to use with the `CreateFacade` methods</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.CreateFacade(DryIoc.IContainer,System.String)">
            <summary>Allows to register new specially keyed services which will facade the same default service,
            registered earlier. May be used to "override" registrations when testing the container.
            Facade will clone the source container singleton and open scope (if any) so
            that you may safely disposing the facade without disposing the source container scopes.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.CreateChild(DryIoc.IContainer,DryIoc.RegistrySharing,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Rules,System.Boolean)">
            <summary>The "child" container detached from the parent container.
            With <paramref name="registrySharing" /> you control how registrations will be shared or separated between the parent and child.
            The not `null` <paramref name="childDefaultServiceKey" /> will allow mark services registered to child with the specified key,
            making them invisible for the parent (if they share the registry). Meanwhile you may resolve them from the child without
            specifying any key. So the `childDefaultServiceKey` is like an invisible stamp on the child registration.
            </summary>
        </member>
        <member name="M:DryIoc.ContainerTools.CreateChild(DryIoc.IContainer,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Rules,System.Boolean)">
            <summary>The "child" container detached from the parent:
            Child creation has O(1) cost - it is cheap thanks to the fast immutable collections cloning.
            Child has all parent registrations copied, then the registrations added or removed in the child are not affecting the parent.
            By default child will use the parent <see cref="T:DryIoc.IfAlreadyRegistered"/> policy - you may specify `IfAlreadyRegistered.Replace` to "shadow" the parent registrations
            Child has an access to the scoped services and singletons already created by parent.
            Child can be disposed without affecting the parent, disposing the child will dispose only the scoped services and singletons created in the child and not in the parent (can be opt-out)</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.With(DryIoc.IContainer,System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Shares all of container state except the cache and the new rules.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithExpressionGeneration(DryIoc.IContainer,System.Boolean)">
            <summary>Prepares container for expression generation.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithoutCache(DryIoc.IContainer)">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            But it will preserve resolved services in Singleton/Current scope.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithoutSingletonsAndCache(DryIoc.IContainer)">
            <summary>Creates new container with state shared with original, except for the singletons and cache.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithRegistrationsCopy(DryIoc.IContainer,System.Boolean)">
            <summary>Shares the setup with original container but copies the registrations, so the new registrations
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithRegistrationsCopy(DryIoc.IContainer,DryIoc.IsRegistryChangePermitted,System.Boolean)">
            <summary>Shares the setup with original container but copies the registrations, so the new registrations
            won't be visible in original. Registrations include decorators and wrappers as well.
            You may control <see cref="T:DryIoc.IsRegistryChangePermitted" /> behavior and opt-in for the keeping or cloning the cache.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IResolverContext,``0)">
            <summary>For given instance resolves and sets properties and fields.
            It respects <see cref="P:DryIoc.Rules.PropertiesAndFields"/> rules set per container,
            or if rules are not set it uses <see cref="F:DryIoc.PropertiesAndFields.Auto"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IResolverContext,``0,System.String[])">
            <summary>For given instance resolves and sets properties and fields. You may specify what 
            properties and fields.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.New(DryIoc.IContainer,System.Type,DryIoc.Setup,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/> if the TYPE is not registered yet. 
            The note is that container will share the singletons though.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.New(DryIoc.IContainer,System.Type,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="concreteType">Type to instantiate. Wrappers (Func, Lazy, etc.) is also supported.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, 
            properties and fields.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <typeparam name="T">Type to instantiate.</typeparam>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made.TypedMade{``0},DryIoc.RegistrySharing)">
            <summary>Creates service given strongly-typed creation expression.
            Can be used to invoke arbitrary method returning some value with injecting its parameters from container.</summary>
            <typeparam name="T">Method or constructor result type.</typeparam>
            <param name="container">Container to use for injecting dependencies.</param>
            <param name="made">Creation expression.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Created result.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: please use WithAutoFallbackDynamicRegistration</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            Obsolete: please use WithAutoFallbackDynamicRegistration
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.DynamicRegistrationFlags,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,DryIoc.Setup,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Reflection.Assembly}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.DynamicRegistrationFlags,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Reflection.Assembly}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Reflection.Assembly[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithDependencies(DryIoc.IContainer,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates new container with provided parameters and properties
            to pass the custom dependency values for injection. The old parameters and properties are overridden,
            but not replaced.</summary>
            <param name="container">Container to work with.</param>
            <param name="parameters">(optional) Parameters specification, can be used to proved custom values.</param>
            <param name="propertiesAndFields">(optional) Properties and fields specification, can be used to proved custom values.</param>
            <returns>New container with adjusted rules.</returns>
            <example><code lang="cs"><![CDATA[
                var c = container.WithDependencies(Parameters.Of.Type<string>(_ => "Nya!"));
                var a = c.Resolve<A>(); // where A accepts string parameter in constructor
                Assert.AreEqual("Nya!", a.Message)
            ]]></code></example>
        </member>
        <member name="T:DryIoc.ContainerTools.GeneratedExpressions">
            <summary>Result of GenerateResolutionExpressions methods</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.Roots">
            <summary>Resolutions roots</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.ResolveDependencies">
            <summary>Dependency of Resolve calls</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.Errors">
            <summary>Errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Func{System.Collections.Generic.IEnumerable{DryIoc.ServiceRegistrationInfo},System.Collections.Generic.IEnumerable{DryIoc.ServiceInfo}},System.Boolean)">
            <summary>Generates expressions for specified roots and their "Resolve-call" dependencies.
            Wraps exceptions into errors. The method does not create any actual services.
            You may use Factory <see cref="P:DryIoc.Setup.AsResolutionRoot"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Generates expressions for provided root services</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Generates expressions for provided root services</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.DefaultValidateCondition(DryIoc.ServiceRegistrationInfo)">
            <summary>Excluding open-generic registrations, cause you need to provide type arguments to actually create these types.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Helps to find potential problems in service registration setup. Method tries to resolve the specified registrations, collects exceptions, 
            and returns them to user. Does not create any actual service objects. You must specify <paramref name="condition"/> to define your resolution roots,
            otherwise container will try to resolve all registrations, which usually is not realistic case to validate.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ValidateAndThrow(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Helps to find potential problems when resolving the <paramref name="roots"/>.
            Method will collect the exceptions when resolving or injecting the specific root. Does not create any actual service objects.
            You must specify <paramref name="roots"/> to define your resolution roots, otherwise container will try to resolve all registrations, 
            which usually is not realistic case to validate.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ValidateAndThrow(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GetRequestExpression(DryIoc.IContainer,DryIoc.Request,DryIoc.RequestFlags)">
            <summary>Re-constructs the whole request chain as request creation expression.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ValidateAndThrow(DryIoc.IContainer,System.Type[])">
            <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache``1(DryIoc.IContainer,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified <typeparamref name="T"/>.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,System.Type[])">
            <summary>Helps to find potential problems in service registration setup by trying to resolve the <paramref name="serviceTypes"/> and 
            returning the found errors. This method does not throw.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache(DryIoc.IContainer,System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified service.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Use(DryIoc.IContainer,System.Type,DryIoc.FactoryDelegate)">
            <summary>Setting the factory directly to scope for resolution</summary> 
        </member>
        <member name="T:DryIoc.IConvertibleToExpression">
            <summary>Interface used to convert reuse instance to expression.</summary>
        </member>
        <member name="M:DryIoc.IConvertibleToExpression.ToExpression(System.Func{System.Object,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <summary>Returns expression representation without closure.
            Use <paramref name="fallbackConverter"/> to converting the sub-items, constants to container.</summary>
        </member>
        <member name="T:DryIoc.DefaultKey">
            <summary>Used to represent multiple default service keys.
            Exposes <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/> to determine order of service added.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.RegistrationOrder">
            <summary>Allows to determine service registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Of(System.Int32)">
            <summary>Returns the default key with specified registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.ToExpression(System.Func{System.Object,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <summary>Converts to expression</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Next">
            <summary>Returns next default key with increased <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/>.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Equals(System.Object)">
            <summary>Compares keys based on registration order. The null (represents default) key is considered equal.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.GetHashCode">
            <summary>Returns registration order as hash.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.ToString">
            <summary>Prints registration order to string.</summary>
        </member>
        <member name="T:DryIoc.DefaultDynamicKey">
            <summary>Represents default key for dynamic registrations</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.RegistrationOrder">
            <summary>Associated ID.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Of(System.Int32)">
            <summary>Returns dynamic key with specified ID.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToExpression(System.Func{System.Object,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <summary>Converts to expression</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Next">
            <summary>Returns next dynamic key with increased <see cref="F:DryIoc.DefaultDynamicKey.RegistrationOrder"/>.</summary> 
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Equals(System.Object)">
            <summary>Compares key's IDs. The null (default) key is considered equal!</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.GetHashCode">
            <summary>Returns key index as hash.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToString">
            <summary>Prints registration order to string.</summary>
        </member>
        <member name="T:DryIoc.IResolverContext">
            <summary>Extends IResolver to provide an access to scope hierarchy.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.IsDisposed">
            <summary>True if container is disposed.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.DisposeInfo">
            <summary>Usually the disposal stack trace (if supported) to add the error message 
            to identify the place and possible reason of disposal. The `null` otherwise</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Parent">
            <summary>Parent context of the scoped context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Root">
            <summary>The root context of the scoped context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.SingletonScope">
            <summary>Singleton scope, always associated with root scope.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.ScopeContext">
            <summary>Optional ambient scope context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.CurrentScope">
            <summary>Current opened scope. May return the current scope from <see cref="P:DryIoc.IResolverContext.ScopeContext"/> if context is not null.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.CurrentOrSingletonScope">
            <summary>This property exist mostly for the performance reasons to have single virtual call instead of 
            `CurrentScope ?? SingletonScope`</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.OwnCurrentScope">
            <summary>The current scope belonged to the resolver context and not to the scope context. Maybe null if ScopeContext is not null.</summary>
        </member>
        <member name="M:DryIoc.IResolverContext.WithCurrentScope(DryIoc.IScope)">
            <summary>Creates the resolver context with specified current Container-OWN scope</summary>
        </member>
        <member name="M:DryIoc.IResolverContext.Use(System.Type,System.Object)">
            <summary>Puts instance created via the passed factory on demand into the current or singleton scope</summary>
        </member>
        <member name="M:DryIoc.IResolverContext.InjectPropertiesAndFields(System.Object,System.String[])">
            <summary>For given instance resolves and sets properties and fields.</summary>
        </member>
        <member name="T:DryIoc.ResolverContext">
            <summary>Provides a usable abstractions for <see cref="T:DryIoc.IResolverContext"/></summary>
        </member>
        <member name="M:DryIoc.ResolverContext.RootOrSelf(DryIoc.IResolverContext)">
            <summary>Just a sugar that allow to get root or self container.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetRootOrSelfExpr(DryIoc.Request)">
            <summary>Finds the correct resolver context expression for e.g. resolution calls dependency,
            or for the injecting the resolver context as parameter, opening the resolution scope, etc.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.RootOrSelfExpr">
            <summary>Root or the current resolver context (if it is the root).</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.SingletonScopeExpr">
            <summary>Resolver parameter expression.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.CurrentScopeExpr">
            <summary>Access to the current scope.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.CurrentOrSingletonScopeExpr">
            <summary>Access to the current scope or singletons.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.IsScoped(DryIoc.IResolverContext)">
            <summary>Indicates that context is scoped - that's is only possible if container is not the Root one and has a Parent context</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetCurrentScopeOrThrow(DryIoc.IResolverContext)">
            <summary>Get current scope or throw the exception otherwise.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.GetCurrentScopeOrThrowExpr">
            <summary>Get current scope expression or throw the exception otherwise.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetCurrentScope(DryIoc.IResolverContext,System.Boolean)">
            <summary>Provides access to the current scope - may return `null` if ambient scope context has it scope changed in-between</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetNamedScope(DryIoc.IResolverContext,System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/></summary>
        </member>
        <member name="M:DryIoc.ResolverContext.OpenScope(DryIoc.IResolverContext,System.Object,System.Boolean)">
            <summary>Opens scope with optional name and optional tracking of new scope in a parent scope.</summary>
            <param name="r">Parent context to use.</param>
            <param name="name">(optional)</param>
            <param name="trackInParent">(optional) Instructs to additionally store the opened scope in parent, 
            so it will be disposed when parent is disposed. If no parent scope is available the scope will be tracked by Singleton scope.
            Used to dispose a resolution scope.</param>
            <returns>Scoped resolver context.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scope = container.OpenScope())
            {
                var handler = scope.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="M:DryIoc.ResolverContext.OpenScope(DryIoc.IResolverContext)">
            <summary>Opens scope with optional name and optional tracking of new scope in a parent scope.</summary>
            <example><code lang="cs"><![CDATA[
            using (var scope = container.OpenScope())
            {
                var handler = scope.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="M:DryIoc.ResolverContext.IsUsed(DryIoc.IResolverContext,System.Type)">
            <summary>Check if the service instance or factory is added to the current or singleton scope</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.IsUsed``1(DryIoc.IResolverContext)">
            <summary>Check if the service instance or factory is added to the current or singleton scope</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.TrackDisposable``1(DryIoc.IResolverContext,``0,System.Int32)">
            <summary>A bit if sugar to track disposable in the current scope or in the singleton scope as a fallback</summary>
        </member>
        <member name="T:DryIoc.FactoryDelegate">
            <summary>The result delegate generated by DryIoc for service creation.</summary>
        </member>
        <member name="T:DryIoc.FactoryDelegate`1">
            <summary>The stronly typed delegate for service creation registered as a Wrapper.</summary>
        </member>
        <member name="T:DryIoc.WrappersSupport">
            <summary>Adds to Container support for:
            <list type="bullet">
            <item>Open-generic services</item>
            <item>Service generics wrappers and arrays using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> extension point.
            Supported wrappers include: Func of <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, Lazy, Many, IEnumerable, arrays, Meta, KeyValuePair, DebugExpression.
            All wrapper factories are added into collection of <see cref="F:DryIoc.WrappersSupport.Wrappers"/>.
            unregistered resolution rule.</item>
            </list></summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.FuncTypes">
            <summary>Supported Func types.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.ActionTypes">
            <summary>Supported Action types. Yeah, action I can resolve or inject void returning method as action.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.SupportedCollectionTypes">
            <summary>Supported open-generic collection types - all the interfaces implemented by array.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFunc(System.Type)">
            <summary>Returns true if type is supported <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, and false otherwise.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.Wrappers">
            <summary>Registered wrappers by their concrete or generic definition service type.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetLazyExpressionOrDefault(DryIoc.Request,DryIoc.Factory)">
            <summary>Gets the expression for <see cref="T:System.Lazy`1"/> wrapper.</summary>
            <param name="request">The resolution request.</param>
            <param name="serviceFactory">The already resolved factory by the collection or the higher wrapper.</param>
            <returns>Expression: <c><![CDATA[r => new Lazy<TService>(() => r.Resolve{TService}(key, ifUnresolved, requiredType))]]></c></returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetFuncOrActionExpressionOrDefault(DryIoc.Request,DryIoc.Factory)">
            <summary>Exposing for creation of custom delegates #243</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetMetaExpressionOrDefault(DryIoc.Request,DryIoc.Factory)">
            <summary>Discovers and combines service with its setup metadata.
            Works with any generic type with first Type arg - Service type and second Type arg - Metadata type,
            and constructor with Service and Metadata arguments respectively.
            - if service key is not specified in request then method will search for all
            registered factories with the same metadata type ignoring keys.
            - if metadata is IDictionary{string, object},
             then the First value matching the TMetadata type will be returned.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.MatchMetadataType(DryIoc.Factory,System.Type)">
            <summary>Find out if factory metadata is matches the passed metadata type</summary>
        </member>
        <member name="T:DryIoc.DynamicRegistration">
            <summary>Represents info required for dynamic registration: service key, factory,
            and <see cref="F:DryIoc.DynamicRegistration.IfAlreadyRegistered"/> option how to combine dynamic with normal registrations.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.Factory">
            <summary>Factory</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.IfAlreadyRegistered">
            <summary>Optional: will be <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/> by default.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.ServiceKey">
            <summary>Optional service key: if null the default <see cref="T:DryIoc.DefaultDynamicKey"/> will be used. </summary>
        </member>
        <member name="M:DryIoc.DynamicRegistration.#ctor(DryIoc.Factory,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Constructs the registration</summary>
        </member>
        <member name="T:DryIoc.DynamicRegistrationFlags">
            <summary>The options for the single dynamic registration provider.
            The dynamic Wrapper registration is not supported.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.NoFlags">
            <summary>No flags - to use in `HasDynamicRegistrationProvider`</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.AsFallback">
            <summary>Use as AsFallback only</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.Service">
            <summary>Provider may have the services provided</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.Decorator">
            <summary>Provider may have the decorators provided</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.DecoratorOfAnyTypeViaObjectServiceType">
            <summary>Specifies that provider should be asked for the `object` service type to get the decorator for the generic `T` service</summary>
        </member>
        <member name="T:DryIoc.Rules">
            <summary> Defines resolution/registration rules associated with Container instance. They may be different for different containers.</summary>
        </member>
        <member name="F:DryIoc.Rules.Default">
            <summary>Default rules as a staring point.</summary>
        </member>
        <member name="M:DryIoc.Rules.HasMicrosoftDependencyInjectionRules">
            <summary>Checks if the rules include the same settings and conventions as <see cref="F:DryIoc.Rules.MicrosoftDependencyInjectionRules"/>.
            It also means that the rules may include the additional things like `WithConcreteTypeDynamicRegistrations`, etc.</summary>
        </member>
        <member name="F:DryIoc.Rules.MicrosoftDependencyInjectionRules">
            <summary>The rules implementing the conventions of Microsoft.Extension.DependencyInjection library.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithMicrosoftDependencyInjectionRules">
            <summary>Returns the copy of the rules with the applied conventions of Microsoft.Extension.DependencyInjection library.
            Before calling this method to avoid the copying you may consider to check if the rules are already <see cref="M:DryIoc.Rules.HasMicrosoftDependencyInjectionRules"/>.
            </summary>
        </member>
        <member name="M:DryIoc.Rules.WithServiceProviderGetServiceShouldThrowIfUnresolved">
            <summary>By default the `IServiceProvider.GetService` is returning `null` if service is not resolved. 
            So you need to call the `GetRequiredService` extension method which in turn requires the implementation of `ISupportRequiredService` underneath.
            To help with this mess you may use this rule to force the `GetService` to throw an exception the same as calling `GetRequiredService`.
            This may help to diagnose the problems in debug or in tests, or in some custom setup.</summary>
        </member>
        <member name="P:DryIoc.Rules.ServiceProviderGetServiceShouldThrowIfUnresolved">
            <summary><see cref="M:DryIoc.Rules.WithServiceProviderGetServiceShouldThrowIfUnresolved"/></summary>
        </member>
        <member name="F:DryIoc.Rules.DefaultDependencyCountInLambdaToSplitBigObjectGraph">
            <summary>The default total dependency count - a expression tree node count to split the object graph</summary>
        </member>
        <member name="P:DryIoc.Rules.DependencyCountInLambdaToSplitBigObjectGraph">
             <summary>The total dependency count - the expression tree node count to split the object graph.
             That does not mean the graph can be always split at this number, consider the example graph and
             the dependency count threshold set to 3:
            
             `x = new X(new Y(A, new B(K), new C(new L(), new M())), new Z())`
             
             The tree is resolved from the left to the right in the depth-first order:
             A; then K, B (at this point Y is already has 3 dependencies but is not fully resolved until C is resolved);
             then L, M, C (here Y is fully resolved with 6 dependencies) so we can split it only on 6 dependencies instead of 3.
            
             The split itseft just wraps the node in `Func{T}` delegate making it a separate compilation unit.
             In our example it will be `Func{Y} f = () => new Y(A, new B(K), new C(new L(), new M()))` considering
             that everything is transient.
             </summary>
        </member>
        <member name="M:DryIoc.Rules.WithDependencyCountInLambdaToSplitBigObjectGraph(System.Int32)">
            <summary>Sets the <see cref="P:DryIoc.Rules.DependencyCountInLambdaToSplitBigObjectGraph"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutDependencyCountInLambdaToSplitBigObjectGraph">
            <summary>Disables the <see cref="P:DryIoc.Rules.DependencyCountInLambdaToSplitBigObjectGraph"/> limitation.</summary>
        </member>
        <member name="P:DryIoc.Rules.FactoryMethodOrSelector">
            <summary>Shorthand to <see cref="P:DryIoc.Made.FactoryMethodOrSelector"/></summary>
        </member>
        <member name="P:DryIoc.Rules.Parameters">
            <summary>Shorthand to <see cref="P:DryIoc.Made.Parameters"/></summary>
        </member>
        <member name="P:DryIoc.Rules.PropertiesAndFields">
            <summary>Shorthand to <see cref="P:DryIoc.Made.PropertiesAndFields"/></summary>
        </member>
        <member name="P:DryIoc.Rules.OverrideRegistrationMade">
            <summary>Instructs to override per-registration made settings with these rules settings.</summary>
        </member>
        <member name="M:DryIoc.Rules.TryGetParameterSelector(DryIoc.Made)">
            <summary>Returns the parameter selector based on <see cref="P:DryIoc.Rules.OverrideRegistrationMade"/></summary>
        </member>
        <member name="M:DryIoc.Rules.TryGetPropertiesAndFieldsSelector(DryIoc.Made)">
            <summary>Returns the properties and fields selectorbased on <see cref="P:DryIoc.Rules.OverrideRegistrationMade"/></summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Returns new instance of the rules new Made composed out of
            provided factory method, parameters, propertiesAndFields.</summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.Made,System.Boolean)">
            <summary>Returns new instance of the rules with specified <see cref="T:DryIoc.Made"/>.</summary>
            <param name="made">New Made.Of rules.</param>
            <param name="overrideRegistrationMade">Instructs to override registration level Made.Of</param>
            <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.DefaultRegistrationServiceKey">
            <summary>Service key to be used instead on `null` in registration.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultRegistrationServiceKey(System.Object)">
            <summary>Sets the <see cref="P:DryIoc.Rules.DefaultRegistrationServiceKey"/></summary>
        </member>
        <member name="T:DryIoc.Rules.FactorySelectorRule">
            <summary>Defines single factory selector delegate. 
            The only one of the passed parameters `singleDefaultFactory` or `orManyDefaultAndKeyedFactories` is not `null`</summary>
            <returns>Single selected factory or null if unable to select.</returns>
        </member>
        <member name="P:DryIoc.Rules.FactorySelector">
            <summary>Rules to select single matched factory default and keyed registered factory/factories.
            Selectors applied in specified array order, until first returns not null <see cref="T:DryIoc.Factory"/>.
            Default behavior is to throw on multiple registered default factories, cause it is not obvious what to use.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFactorySelector(DryIoc.Rules.FactorySelectorRule)">
            <summary>Sets <see cref="P:DryIoc.Rules.FactorySelector"/></summary>
        </member>
        <member name="M:DryIoc.Rules.SelectLastRegisteredFactory">
            <summary>Select last registered factory from the multiple default.</summary>
        </member>
        <member name="P:DryIoc.Rules.IsSelectLastRegisteredFactory">
            <summary>A commonly used rule, the flag is for optimization</summary>
        </member>
        <member name="M:DryIoc.Rules.SelectFactoryWithTheMinReuseLifespan">
            <summary>Tries to select a single factory based on the minimal reuse life-span ignoring the Transients</summary>
        </member>
        <member name="M:DryIoc.Rules.SelectFactoryWithTheMinReuseLifespanOrLastRegistered">
            <summary>Tries either SelectFactoryWithTheMinReuseLifespan or SelectLastRegisteredFactory</summary>
        </member>
        <member name="M:DryIoc.Rules.SelectKeyedOverDefaultFactory(System.Object)">
            <summary>Prefer specified service key (if found) over default key.
            Help to override default registrations in Open Scope scenarios:
            I may register service with key and resolve it as default in current scope.</summary>
        </member>
        <member name="T:DryIoc.Rules.DynamicRegistrationProvider">
            <summary>Specify the method signature for returning multiple keyed factories.
            This is dynamic analog to the normal Container Registry.</summary>
            <param name="serviceType">Requested service type.</param>
            <param name="serviceKey">(optional) If <c>null</c> will request all factories of <paramref name="serviceType"/></param>
            <returns>Key-Factory pairs.</returns>
        </member>
        <member name="P:DryIoc.Rules.DynamicRegistrationProviders">
            <summary>Providers for resolving multiple not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.HasDynamicRegistrationProvider(DryIoc.DynamicRegistrationFlags,DryIoc.DynamicRegistrationFlags)">
            <summary>Get the specific providers with the specified flags and without the flags or return `null` if nothing found</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistration(DryIoc.Rules.DynamicRegistrationProvider,DryIoc.DynamicRegistrationFlags)">
            <summary>Returns the new rules with the passed dynamic registration rule appended.</summary>
        </member>
        <member name="P:DryIoc.Rules.DynamicRegistrationFlags">
            <summary>The flags per dynamic registration provider</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Returns the new rules with the passed dynamic registration rules appended.</summary>
        </member>
        <member name="F:DryIoc.Rules.DefaultDynamicRegistrationFlags">
            <summary>Only services and no decorators as it will greately affect the performance, 
            calling the provider for every resolved service</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrationsAsFallback(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Returns the new rules with the passed dynamic registration rules appended. 
            The rules applied only when no normal registrations found!</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.DynamicRegistrationFlags,DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Returns the new rules with the passed dynamic registration rules appended. 
            The rules applied only when no normal registrations found!</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrationsAsFallback(DryIoc.DynamicRegistrationFlags,DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Returns the new rules with the passed dynamic registration rules appended. 
            The rules applied only when no normal registrations found!</summary>
        </member>
        <member name="P:DryIoc.Rules.UseDynamicRegistrationsAsFallbackOnly">
            <summary>Obsolete: Instead use `HasDynamicRegistrationProvider(DynamicRegistrationFlags.AsFallback)`</summary>
        </member>
        <member name="T:DryIoc.Rules.UnknownServiceResolver">
            <summary>Defines delegate to return factory for request not resolved by registered factories or prior rules.
            Applied in specified array order until return not null <see cref="T:DryIoc.Factory"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.UnknownServiceResolvers">
            <summary>Gets rules for resolving not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])">
            <summary>Appends resolver to current unknown service resolvers.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver)">
            <summary>Removes specified resolver from unknown service resolvers, and returns new Rules.
            If no resolver was found then <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> will stay the same instance,
            so it could be check for remove success or fail.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceHandler(System.Action{DryIoc.Request})">
            <summary>Sugar on top of <see cref="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])"/> to simplify setting the diagnostic action.
            Does not guard you from action throwing an exception. Actually can be used to throw your custom exception
            instead of <see cref="T:DryIoc.ContainerException"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.AutoResolveConcreteTypeRule(System.Func{DryIoc.Request,System.Boolean})">
            <summary>The alternative is ConcreteTypeDynamicRegistrations</summary>
        </member>
        <member name="M:DryIoc.Rules.ConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract, nor registered wrapper type.
            For constructor selection we are using automatic constructor selection.</summary>
            <param name="condition">(optional) Condition for requested service type and key.</param>
            <param name="reuse">(optional) Reuse for concrete types.</param>
            <returns>New rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.ConcreteTypeDynamicRegistrations(DryIoc.IfUnresolved,System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract, nor registered wrapper type.
            For constructor selection we are using automatic constructor selection.
            Pass `IfUnresolved.ReturnDefault` or `IfUnresolved.ReturnDefaultIfNotRegistered` to `ifConcreteTypeIsUnresolved` 
            to allow fallback to the next rule.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithConcreteTypeDynamicRegistrations(DryIoc.IfUnresolved,System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.
            Pass `IfUnresolved.ReturnDefault` or `IfUnresolved.ReturnDefaultIfNotRegistered` to `ifConcreteTypeIsUnresolved` 
            to allow fallback to the next rule.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithAutoConcreteTypeResolution(System.Func{DryIoc.Request,System.Boolean})">
            [Obsolete("Replaced with `WithConcreteTypeDynamicRegistrations`")]
        </member>
        <member name="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Creates dynamic fallback registrations for the requested service type
            with provided <paramref name="getImplementationTypes"/>.
            Fallback means that the dynamic registrations will be applied Only if no normal registrations
            exist for the requested service type, hence the "fallback".</summary>
            <param name="getImplementationTypes">Implementation types to select for service.</param>
            <param name="factory">(optional) Handler to customize the factory, e.g.
            specify reuse or setup. Handler should not return <c>null</c>.</param>
            <returns>Registration provider.</returns>
        </member>
        <member name="M:DryIoc.Rules.AutoRegisterUnknownServiceRule(System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: replaced by <see cref="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})"/></summary>
        </member>
        <member name="P:DryIoc.Rules.DefaultReuse">
            <summary>See <see cref="M:DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse)"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse)">
            <summary>The reuse used in case if reuse is unspecified (null) in Register methods.</summary>
        </member>
        <member name="T:DryIoc.Rules.ItemToExpressionConverterRule">
            <summary>Given item object and its type should return item "pure" expression presentation,
            without side-effects or external dependencies.
            e.g. for string "blah" <code lang="cs"><![CDATA[]]>Expression.Constant("blah", typeof(string))</code>.
            If unable to convert should return null.</summary>
        </member>
        <member name="P:DryIoc.Rules.ItemToExpressionConverter">
            <summary><see cref="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)">
            <summary>Specifies custom rule to convert non-primitive items to their expression representation.
            That may be required because DryIoc by default does not support non-primitive service keys and registration metadata.
            To enable non-primitive values support DryIoc need a way to recreate them as expression tree.</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan">
            <summary>Turns off throwing exception when dependency has shorter reuse lifespan than its parent or ancestor.</summary>
            <returns>New rules with new setting value.</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfScopedOrSingletonHasTransientDependency">
            <summary><see cref="M:DryIoc.Rules.WithThrowIfScopedOrSingletonHasTransientDependency"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithThrowIfScopedOrSingletonHasTransientDependency">
            <summary>Turns On throwing the exception when Singleton or Scope service has a Transient dependency</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfScopedOrSingletonHasTransientDependency">
            <summary>Turns Off throwing the exception when Singleton or Scope service has a Transient dependency (the default)</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient">
            <summary>Turns Off the rule <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.
            Allows to register disposable transient but it is up to you to handle their disposal.
            You can use <see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/> to actually track disposable transient in
            container, so that disposal will be handled by container.</summary>
        </member>
        <member name="P:DryIoc.Rules.TrackingDisposableTransients">
            <summary><see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithTrackingDisposableTransients">
             <summary>
             Turns on the storing of disposable transients in the current scope or in the singleton scope if no scopes are opened.
             It is required to be able to Dispose the Transient at specific time when the scope is disposed or where container
             with singletons is disposed.
            
             The storing disposable transients in the singleton scope means that they won't be disposed until
             the whole container is disposed. That may pose a problem similar to the "memory leak" because more and more transients
             will be created and stored never disposed until whole container is disposed. Therefore you 
             need to think if you really need the disposable to be the Transient. Whatever, just be aware of it.
             </summary>
        </member>
        <member name="P:DryIoc.Rules.EagerCachingSingletonForFasterAccess">
            <summary><see cref="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutTrackingDisposableTransients">
            <summary>
            The opposite of <see cref="M:DryIoc.Rules.WithTrackingDisposableTransients" /> removing the tracking, 
            which maybe helpful e.g. for undoing the rule from the Microsoft.DependencyInjection conforming rules.
            </summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess">
            <summary>Turns off optimization: creating singletons during resolution of object graph.</summary>
        </member>
        <member name="P:DryIoc.Rules.DependencyResolutionCallExprs">
            <summary><see cref="M:DryIoc.Rules.WithExpressionGeneration(System.Boolean)"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.UsedForExpressionGeneration">
            <summary>Indicates that container is used for generation purposes, so it should use less runtime state</summary>
        </member>
        <member name="M:DryIoc.Rules.WithExpressionGeneration(System.Boolean)">
            <summary>Specifies to generate ResolutionCall dependency creation expression and stores the result 
            in the-per rules collection.</summary>
        </member>
        <member name="M:DryIoc.Rules.ForExpressionGeneration(System.Boolean)">
            <summary>Removes runtime optimizations preventing an expression generation.</summary>
        </member>
        <member name="P:DryIoc.Rules.UsedForValidation">
            <summary>Indicates that rules are used for the validation, e.g. the rules created in `Validate` method</summary>
        </member>
        <member name="M:DryIoc.Rules.ForValidate">
            <summary>Specifies to generate ResolutionCall dependency creation expression and stores the result 
            in the-per rules collection.</summary>
        </member>
        <member name="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope">
            <summary><see cref="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutImplicitCheckForReuseMatchingScope">
            <summary>Removes implicit Factory <see cref="P:DryIoc.Setup.Condition"/> for non-transient service.
            The Condition filters out factory without matching scope.</summary>
        </member>
        <member name="P:DryIoc.Rules.ResolveIEnumerableAsLazyEnumerable">
            <summary><see cref="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable">
            <summary>Specifies to resolve IEnumerable as LazyEnumerable.</summary>
        </member>
        <member name="P:DryIoc.Rules.VariantGenericTypesInResolvedCollection">
            <summary><see cref="M:DryIoc.Rules.WithVariantGenericTypesInResolvedCollection"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithVariantGenericTypesInResolvedCollection">
            <summary>Flag instructs to include covariant compatible types into the resolved collection.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection">
            <summary>Flag instructs to exclude covariant compatible types into the resolved collection.</summary>
        </member>
        <member name="P:DryIoc.Rules.VariantGenericTypesInResolve">
            <summary><see cref="M:DryIoc.Rules.WithVariantGenericTypesInResolve"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithVariantGenericTypesInResolve">
            <summary>Flag instructs to include covariant compatible types into the resolved generic.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutVariantGenericTypesInResolve">
            <summary>Flag instructs to exclude covariant compatible types into the resolved generic.</summary>
        </member>
        <member name="P:DryIoc.Rules.DefaultIfAlreadyRegistered">
            <summary><see cref="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)">
            <summary>Specifies default setting for container. By default is <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/>.
            Example of use: specify Keep as a container default, then set AppendNonKeyed for explicit collection registrations.</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfRuntimeStateRequired">
            <summary><see cref="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.ConstantExpressionIsFine">
            <summary>The thing.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired">
            <summary>Specifies to throw an exception in attempt to resolve service which require runtime state for resolution.
            Runtime state may be introduced by RegisterDelegate, RegisterInstance, or registering with non-primitive service key, or metadata.</summary>
        </member>
        <member name="P:DryIoc.Rules.CaptureContainerDisposeStackTrace">
            <summary><see cref="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace">
            <summary>Instructs to capture Dispose stack-trace to include it later into <see cref="F:DryIoc.Error.ContainerIsDisposed"/>
            exception for easy diagnostics.</summary>
        </member>
        <member name="P:DryIoc.Rules.IgnoringReuseForFuncWithArgs">
            <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithIgnoringReuseForFuncWithArgs">
            <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
        </member>
        <member name="P:DryIoc.Rules.FuncAndLazyWithoutRegistration">
            <summary>Allows Func of service to be resolved even without registered service.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFuncAndLazyWithoutRegistration">
            <summary>Allows Func of service to be resolved even without registered service.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutFuncAndLazyWithoutRegistration">
            <summary>Removes the rule `FuncAndLazyWithoutRegistration`.</summary>
        </member>
        <member name="P:DryIoc.Rules.UseInterpretationForTheFirstResolution">
            Subject-subject
        </member>
        <member name="M:DryIoc.Rules.WithoutInterpretationForTheFirstResolution">
            Fallbacks to system `Expression.Compile()`
        </member>
        <member name="P:DryIoc.Rules.UseInterpretation">
            Subject
        </member>
        <member name="M:DryIoc.Rules.WithUseInterpretation">
            <summary>Uses DryIoc own interpretation mechanism or is falling back to `Compile(preferInterpretation: true)`</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutUseInterpretation">
            <summary>Uses DryIoc own interpretation mechanism or is falling back to `Compile(preferInterpretation: true)`</summary>
        </member>
        <member name="P:DryIoc.Rules.UseDecorateeReuseForDecorators">
            <summary>If Decorator reuse is not set instructs to use `Decorator.SetupWith(useDecarateeReuse: true)`</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUseDecorateeReuseForDecorators">
            <summary>If Decorator reuse is not set instructs to use `Decorator.SetupWith(useDecarateeReuse: true)`</summary>
        </member>
        <member name="M:DryIoc.Rules.ToString">
            Outputs most notable non-default rules
        </member>
        <member name="T:DryIoc.FactoryMethod">
            <summary>Wraps constructor or factory method optionally with factory instance to create service.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorOrMethodOrMember">
            <summary>Constructor or method to use for service creation.</summary>
        </member>
        <member name="P:DryIoc.FactoryMethod.FactoryServiceInfo">
            <summary>Identifies factory service if factory method is instance member.</summary>
        </member>
        <member name="P:DryIoc.FactoryMethod.FactoryExpression">
            Alternatively you may just provide an expression for factory
        </member>
        <member name="P:DryIoc.FactoryMethod.ResolvedParameterExpressions">
            <summary> Contains resolved parameter expressions found when looking for most resolvable constructor</summary> 
        </member>
        <member name="M:DryIoc.FactoryMethod.#ctor(System.Reflection.MemberInfo)">
            <summary>Just creates a thingy from the constructor</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo)">
            <summary>Wraps method and factory instance.
            Where <paramref name="ctorOrMethodOrMember"/> is constructor, static or instance method, property or field.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,System.Object)">
            <summary>Wraps method and factory instance.
            Where <paramref name="methodOrMember"/> is constructor, static or instance method, property or field.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of``1(System.String)">
            <summary>Discovers the static factory method or member by name in <typeparamref name="TFactory"/>.
            Should play nice with C# <see langword="nameof"/> operator.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.ToString">
            <summary>Pretty prints wrapped method.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Constructor(System.Boolean,System.Boolean)">
            <summary>Easy way to specify non-public and most resolvable constructor.</summary>
            <param name="mostResolvable">(optional) Instructs to select constructor with max number of params which all are resolvable.</param>
            <param name="includeNonPublic">(optional) Consider the non-public constructors.</param>
            <returns>Constructor or null if not found.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.DefaultConstructor(System.Boolean)">
            <summary>Easy way to specify default constructor to be used for resolution.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublicWithoutSameTypeParam">
            <summary>Searches for a single constructor excluding the ones with the same implementation type as parameter.
            Used by the AutoConcrete type resolution to avoid selection of recursive constructors like `Foo(Foo f)`</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments">
            <summary>Better be named `ConstructorWithMostResolvableArguments`.
            Searches for public constructor with most resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and `Func{TArgs..., TService}`</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic">
            <summary>Searches for constructor (including non public ones) with most resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and for Func{TArgs..., TService}</summary>
        </member>
        <member name="T:DryIoc.Made">
            <summary>Rules how to: <list type="bullet">
            <item>Select constructor for creating service with <see cref="P:DryIoc.Made.FactoryMethodOrSelector"/>.</item>
            <item>Specify how to resolve constructor parameters with <see cref="P:DryIoc.Made.Parameters"/>.</item>
            <item>Specify what properties/fields to resolve and how with <see cref="P:DryIoc.Made.PropertiesAndFields"/>.</item>
            </list></summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethodOrSelector">
            <summary>The factory method or its selector based on the request.</summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethodKnownResultType">
            <summary>Return type of strongly-typed factory method expression.</summary>
        </member>
        <member name="P:DryIoc.Made.Parameters">
            <summary>Specifies how constructor parameters should be resolved:
            parameter service key and type, throw or return default value if parameter is unresolved.</summary>
        </member>
        <member name="P:DryIoc.Made.PropertiesAndFields">
            <summary>Specifies what <see cref="T:DryIoc.ServiceInfo"/> should be used when resolving property or field.</summary>
        </member>
        <member name="P:DryIoc.Made.IsConditional">
            Has any conditional flags
        </member>
        <member name="P:DryIoc.Made.HasCustomDependencyValue">
            <summary>True if made has properties or parameters with custom value.
            That's mean the whole made become context based which affects caching.</summary>
        </member>
        <member name="P:DryIoc.Made.IsConditionalImplementation">
            <summary>Indicates that the implementation type depends on request.</summary>
        </member>
        <member name="P:DryIoc.Made.IsImplMemberDependsOnRequest">
            Indicates that the member depends on request
        </member>
        <member name="M:DryIoc.Made.ToString">
            <summary>Outputs whatever is possible (known) for Made</summary>
        </member>
        <member name="F:DryIoc.Made.Default">
            <summary>Container will use some sensible defaults for service creation.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.FactoryMethodSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethodOrSelector"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.ParameterSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.Parameters"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.PropertiesAndFieldsSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.PropertiesAndFields"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector,System.Boolean)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethod,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory method specification</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Type},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with implementation type, conditionally depending on request.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.
            Where <paramref name="getMethodOrMember"/> is method, or constructor, or member selector.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},System.Func{DryIoc.Request,DryIoc.ServiceInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.
            Where <paramref name="getMethodOrMember"/>Method, or constructor, or member selector.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{System.Type,System.Reflection.ConstructorInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Defines how to select constructor from implementation type.
            Where <paramref name="getConstructor"/> is delegate taking implementation type as input 
            and returning selected constructor info.</summary>
        </member>
        <member name="M:DryIoc.Made.Of``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines factory method using expression of constructor call (with properties), or static method call.</summary>
            <typeparam name="TService">Type with constructor or static method.</typeparam>
            <param name="serviceReturningExpr">Expression tree with call to constructor with properties:
            <code lang="cs"><![CDATA[() => new Car(Arg.Of<IEngine>()) { Color = Arg.Of<Color>("CarColor") }]]></code>
            or static method call <code lang="cs"><![CDATA[() => Car.Create(Arg.Of<IEngine>())]]></code></param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(System.Func{DryIoc.Request,DryIoc.ServiceInfo.Typed{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines creation info from factory method call Expression without using strings.
            You can supply any/default arguments to factory method, they won't be used, it is only to find the <see cref="T:System.Reflection.MethodInfo"/>.</summary>
            <typeparam name="TFactory">Factory type.</typeparam> <typeparam name="TService">Factory product type.</typeparam>
            <param name="getFactoryInfo">Returns or resolves factory instance.</param>
            <param name="serviceReturningExpr">Method, property or field expression returning service.</param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Composes Made.Of expression with known factory instance and expression to get a service</summary>
        </member>
        <member name="T:DryIoc.Made.TypedMade`1">
            <summary>Typed version of <see cref="T:DryIoc.Made"/> specified with statically typed expression tree.</summary>
        </member>
        <member name="P:DryIoc.Made.TypedMade`1.FactoryMethodKnownResultType">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.Arg">
            <summary>Class for defining parameters/properties/fields service info in <see cref="T:DryIoc.Made"/> expressions.
            Arg methods are NOT actually called, they just used to reflect service info from call expression.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1">
            <summary>Specifies required service type of parameter or member. If required type is the same as parameter/member type,
            the method is just a placeholder to help detect constructor or factory method, and does not have additional meaning.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.String,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.String,System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.Arg.Index``1(System.Int32)">
            <summary>Specifies argument index starting from 0 to use corresponding custom value factory,
            similar to String.Format <c>"{0}, {1}, etc"</c>.</summary>
        </member>
        <member name="F:DryIoc.Arg.ArgIndexMethodName">
            <summary>Name is close to method itself to not forget when renaming the method.</summary>
        </member>
        <member name="T:DryIoc.Registrator">
            <summary>Contains <see cref="T:DryIoc.IRegistrator"/> extension methods to simplify general use cases.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.Factory,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>The base method for registering service with its implementation factory. Allows to specify all possible options.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,System.Type,DryIoc.IReuse)">
            <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service of <paramref name="serviceAndMayBeImplementationType"/>.
            ServiceType may be the same as <paramref name="serviceAndMayBeImplementationType"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service of <typeparamref name="TService"/> type
            implemented by <typeparamref name="TImplementation"/> type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers implementation type <typeparamref name="TImplementation"/> with itself as service type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``1},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service returned by Made expression.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IRegistrator,System.Boolean,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegistered`, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.TrackDisposable(DryIoc.IRegistrator,System.Object)">
            <summary>Tracks the disposable instance in the singleton scope</summary>
        </member>
        <member name="M:DryIoc.Registrator.TrackDisposable(DryIoc.IRegistrator,System.Object,DryIoc.Setup)">
            <summary>Tracks the disposable instance in the singleton scope</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IRegistrator,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegestered`, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance``1(DryIoc.IRegistrator,``0,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegistered`, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstanceMany(DryIoc.IRegistrator,System.Type,System.Object,System.Boolean,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
            so you can check it via `IsRegistered` for each service type, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstanceMany``1(DryIoc.IRegistrator,``0,System.Boolean,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
            so you can check it via `IsRegestered` for each service type, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstanceMany(DryIoc.IRegistrator,System.Type[],System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
            so you can check it via `IsRegestered` for each service type, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.IsExcludedGeneralPurposeServiceType(System.Type)">
            <summary>Checks some common .NET types to exclude.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsServiceType(System.Type)">
            <summary>Checks that type can be used a service type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsImplementationType(System.Type)">
            <summary>Checks if type can be used as implementation type for reflection factory,
            and therefore registered to container. Usually used to discover implementation types from assembly.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns only those types that could be used as service types of <paramref name="type"/>.
            It means that for open-generic <paramref name="type"/> its service type should supply all type arguments.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsImplementingServiceType(System.Type,System.Type)">
            <summary>The same `GetImplementedServiceTypes` but instead of collecting the service types just check the <paramref name="serviceType"/> is implemented</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns the sensible services automatically discovered for RegisterMany implementation type.
            Excludes the collection wrapper interfaces. The <paramref name="type"/> may be concrete, abstract or
            generic definition.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementationTypes(System.Reflection.Assembly)">
            <summary>Returns the types suitable to be an implementation types for <see cref="T:DryIoc.ReflectionFactory"/>:
            actually a non abstract and not compiler generated classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementationTypes(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>Returns the types suitable to be an implementation types for <see cref="T:DryIoc.ReflectionFactory"/>:
            actually a non abstract and not compiler generated classes.</summary>
        </member>
        <member name="F:DryIoc.Registrator.Interfaces">
            <summary>Sugar, so you can say <code lang="cs"><![CDATA[r.RegisterMany<X>(Registrator.Interfaces)]]></code></summary>
        </member>
        <member name="M:DryIoc.Registrator.ImplementsServiceType(System.Type,System.Type)">
            <summary>Checks if <paramref name="type"/> implements a service type,
            along the checking if <paramref name="type"/> is a valid implementation type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ImplementsServiceType``1(System.Type)">
            <summary>Checks if <paramref name="type"/> implements a service type,
            along the checking if <paramref name="type"/> and service type
            are valid implementation and service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactory(System.Type)">
            <summary>Wraps the implementation type in factory.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactory(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Wraps the implementation type in factory plus allow to provide factory parameters.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>
            Batch registering the implementations with possibly many service types,
            throwing the <see cref="F:DryIoc.Error.NoServicesWereRegisteredByRegisterMany" /> error when there are no services types to register.
            You may pass the predefined <see cref="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)"/> to <paramref name="getServiceTypes"/>.
            By default <paramref name="getImplFactory"/> uses the <see cref="T:DryIoc.ReflectionFactory"/> with the default reuse,
            or you may return the <see cref="T:DryIoc.ReflectionFactory"/> with the <see cref="T:DryIoc.Reuse"/> of your choice.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterManyIgnoreNoServicesWereRegistered(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>
            Batch registering the implementations with possibly many service types,
            ignoring the case when there are no services types to register.
            You may pass the predefined <see cref="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)"/> to <paramref name="getServiceTypes"/>.
            By default <paramref name="getImplFactory"/> uses the <see cref="T:DryIoc.ReflectionFactory"/> with the default reuse,
            or you may return the <see cref="T:DryIoc.ReflectionFactory"/> with the <see cref="T:DryIoc.Reuse"/> of your choice.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Type[],System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Batch registers implementation with possibly many service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>Batch registers assemblies of implementation types with possibly many service types.
            The default factory is the <see cref="T:DryIoc.ReflectionFactory"/> with default reuse.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Boolean},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers many implementations with auto-figured service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactoryDelegate``1(System.Func{DryIoc.IResolverContext,``0},DryIoc.IResolverContext)">
            Minimizes the number of allocations when converting from Func to named delegate
        </member>
        <member name="M:DryIoc.Registrator.ToFactoryDelegate(System.Object,DryIoc.IResolverContext)">
            Lifts the result to the factory delegate without allocations on capturing value in lambda closure
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers a factory delegate for creating an instance of <typeparamref name="TService"/>.
            Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <remarks>The alternative to this method please consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``2(DryIoc.IRegistrator,System.Func{``0,``1},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Type,System.Func{``0,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container avoiding and with object return type known at runtime</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Type,System.Func{System.Object,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container.
            The delegate accepts the object parameters with the runtime known types</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``3(DryIoc.IRegistrator,System.Func{``0,``1,``2},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``2(DryIoc.IRegistrator,System.Type,System.Func{``0,``1,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container avoiding and with object return type known at runtime</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Type,System.Type,System.Func{System.Object,System.Object,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container.
            The delegate accepts the object parameters with the runtime known types</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``4(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``3(DryIoc.IRegistrator,System.Type,System.Func{``0,``1,``2,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container avoiding and with object return type known at runtime</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Type,System.Type,System.Type,System.Func{System.Object,System.Object,System.Object,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container.
            The delegate accepts the object parameters with the runtime known types</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``5(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``4(DryIoc.IRegistrator,System.Type,System.Func{``0,``1,``2,``3,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container avoiding and with object return type known at runtime</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Type,System.Type,System.Type,System.Type,System.Func{System.Object,System.Object,System.Object,System.Object,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container.
            The delegate accepts the object parameters with the runtime known types</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``6(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4,``5},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``5(DryIoc.IRegistrator,System.Type,System.Func{``0,``1,``2,``3,``4,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container avoiding and with object return type known at runtime</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Type,System.Type,System.Type,System.Type,System.Type,System.Func{System.Object,System.Object,System.Object,System.Object,System.Object,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container.
            The delegate accepts the object parameters with the runtime known types</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``7(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4,``5,``6},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``6(DryIoc.IRegistrator,System.Type,System.Func{``0,``1,``2,``3,``4,``5,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container avoiding and with object return type known at runtime</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Type,System.Type,System.Type,System.Type,System.Type,System.Type,System.Func{System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container.
            The delegate accepts the object parameters with the runtime known types</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``8(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4,``5,``6,``7},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``7(DryIoc.IRegistrator,System.Type,System.Func{``0,``1,``2,``3,``4,``5,``6,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container avoiding and with object return type known at runtime</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Type,System.Type,System.Type,System.Type,System.Type,System.Type,System.Type,System.Func{System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with the explicit arguments to be injected by container.
            The delegate accepts the object parameters with the runtime known types</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Func{DryIoc.IResolverContext,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers a factory delegate for creating an instance of <paramref name="serviceType"/>.
            Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <remarks>IMPORTANT: The method should be used as the last resort only! Though powerful it is a black-box for container,
            which prevents diagnostics, plus it is easy to get memory leaks (due variables captured in delegate closure),
            and impossible to use in compile-time scenarios.
            Consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegateDecorator``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,System.Func{``0,``0}},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete("Replaced with RegisterDelegate{MyService, Dep1...Dep2, MyService}((service, d1, d2) => new MyServiceDecorator(service, d1, d2), setup: Setup.DecoratorWith(useDecorateeReuse: true, condition: optional))")</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IResolverContext,System.Func{DryIoc.IResolverContext,``0})">
            <summary>Adding the factory directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IResolverContext,System.Type,DryIoc.FactoryDelegate)">
            <summary>Adding the factory directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IResolverContext,DryIoc.FactoryDelegate)">
            <summary>Adding the factory directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IResolverContext,System.Type,System.Object)">
            <summary>Adding the instance directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IResolverContext,``0)">
            <summary>Adding the instance directly to the scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,``0})">
            <summary>Adding the factory directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IRegistrator,DryIoc.FactoryDelegate)">
            <summary>Adding the factory directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IRegistrator,System.Type,DryIoc.FactoryDelegate)">
            <summary>Adding the factory directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IRegistrator,System.Type,System.Object)">
            <summary>Adding the instance directly to scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IRegistrator,``0)">
            <summary>Adding the instance directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IContainer,System.Func{DryIoc.IResolverContext,``0})">
            <summary>Adding the factory directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IContainer,DryIoc.FactoryDelegate)">
            <summary>Adding the factory directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IContainer,System.Type,DryIoc.FactoryDelegate)">
            <summary>Adding the factory directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IContainer,System.Type,System.Object)">
            <summary>Adding the instance directly to scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IContainer,``0)">
            <summary>Adding the instance directly to scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolverContext},System.Func{DryIoc.Request,System.Boolean})">
            <summary>
            Registers initializing action that will be called after service is resolved 
            just before returning it to the caller. You can register multiple initializers for a single service.
            Or you can register initializer for the <see cref="T:System.Object"/> type to be applied 
            for all services and use <paramref name="condition"/> to specify the target services.
            Note: The initializer action has the same reuse as a initialized (decorated) service.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolverContext},DryIoc.IReuse,System.Func{DryIoc.Request,System.Boolean})">
            <summary>
            Registers initializing action that will be called after service is resolved 
            just before returning it to the caller. You can register multiple initializers for a single service.
            Or you can register initializer for the <see cref="T:System.Object"/> type to be applied 
            for all services and use <paramref name="condition"/> to specify the target services.
            Note: You may specify a <paramref name="reuse"/> different from the initiliazed object enabling the
            <paramref name="initialize"/> action to run once (Singleton), run once-per-scope (Scoped), run always (Transient).
            Note2: By convention the initializer is not applied for wrappers (collections, Func, Lazy, etc.). If you need this you may directly use the decorator.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDisposer``1(DryIoc.IRegistrator,System.Action{``0},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Registers dispose action for reused target service.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <paramref name="serviceType"/> is registered in container OR
            its open generic definition is registered in container.
            The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <typeparamref name="TService"/> is registered in container OR
            its open generic definition is registered in container.
            The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Unregister(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.
            It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
            Check the docs for more info: https://github.com/dadhi/DryIoc/blob/master/docs/DryIoc.Docs/UnregisterAndResolutionCache.md </summary>
        </member>
        <member name="M:DryIoc.Registrator.Unregister``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.
            It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
            Check the docs for more info: https://github.com/dadhi/DryIoc/blob/master/docs/DryIoc.Docs/UnregisterAndResolutionCache.md </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping(DryIoc.IRegistrator,System.Type,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="registrator">Registrator</param> <param name="serviceType">New service type.</param>
            <param name="registeredServiceType">Existing registered service type.</param>
            <param name="ifAlreadyRegistered">The registration to overwrite or preserve the already registered service</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <param name="factoryType">(optional) By default is <see cref="F:DryIoc.FactoryType.Service"/></param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping(DryIoc.IRegistrator,System.Type,System.Type,System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping``2(DryIoc.IRegistrator,System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="registrator">Registrator</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <param name="factoryType">(optional) By default is <see cref="F:DryIoc.FactoryType.Service"/></param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterPlaceholder(DryIoc.IRegistrator,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with `IfAlreadyRegistered.Replace` parameter.
            When the implementation is still not provided when the placeholder service is accessed, then the exception will be thrown.
            This feature allows you to postpone the decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup `asResolutionCall: true`.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterPlaceholder``1(DryIoc.IRegistrator,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with `IfAlreadyRegistered.Replace` parameter.
            When the implementation is still not provided when the placeholder service is accessed,then the exception will be thrown.
            This feature allows you to postpone decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup `asResolutionCall: true`.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping``2(DryIoc.IContainer,DryIoc.IfAlreadyRegistered,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="ifAlreadyRegistered">The registration to overwrite or preserve the already registered service</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
        </member>
        <member name="T:DryIoc.Resolver">
            <summary>Extension methods for <see cref="T:DryIoc.IResolver"/>.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type)">
            <summary>Resolves instance of service type from container. Throws exception if unable to resolve.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Resolves instance of service type from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,DryIoc.IfUnresolved)">
            <summary>Resolves instance of type TService from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Boolean)">
            <summary>Tries to resolve instance of service type from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Boolean)">
            <summary>Tries to resolve instance of TService from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Type,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(IEnumerable<object>), typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <paramref name="requiredServiceType"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>>(typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``2(DryIoc.IResolver,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <typeparamref name="TRequiredService"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <typeparamref name="TRequiredService"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>, IService>();
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,System.Object[])">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(Lazy<object>), "someKey", requiredServiceType: typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object,DryIoc.IfUnresolved,System.Type,System.Object[])">
            <summary>Returns instance of <typeparamref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object[],DryIoc.IfUnresolved,System.Type,System.Object)">
            <summary>Resolves the service supplying all or some of its dependencies 
            (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
            container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object[],DryIoc.IfUnresolved,System.Type,System.Object)">
            <summary>Resolves the service supplying all or some of its dependencies 
            (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
            container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)">
            <summary>Returns all registered services instances including all keyed and default registrations.
            Use <paramref name="behavior"/> to return either all registered services at the moment of resolve (dynamic fresh view) or
            the same services that were returned with first <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)"/> call (fixed view).</summary>
            <typeparam name="TService">Return collection item type. 
            It denotes registered service type if <paramref name="requiredServiceType"/> is not specified.</typeparam>
            <remarks>The same result could be achieved by directly calling:
            <code lang="cs"><![CDATA[
                container.Resolve<LazyEnumerable<IService>>();  // for dynamic result - default behavior
                container.Resolve<IService[]>();                // for fixed array
                container.Resolve<IEnumerable<IService>>();     // same as fixed array
            ]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)">
            <summary>Returns all registered services as objects, including all keyed and default registrations.</summary>
        </member>
        <member name="M:DryIoc.Resolver.New(DryIoc.IResolver,System.Type,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.New``1(DryIoc.IResolver,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.New``1(DryIoc.IResolver,DryIoc.Made.TypedMade{``0},DryIoc.RegistrySharing)">
            <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.CreateResolutionExpression(DryIoc.Request,System.Boolean,System.Boolean)">
            <summary>Used for internal purposes to create the expression of Resolve method of the passed `request`</summary>
        </member>
        <member name="T:DryIoc.ResolveManyBehavior">
            <summary>Specifies result of <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)"/>: either dynamic(lazy) or fixed view.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsLazyEnumerable">
            <summary>Lazy/dynamic item resolve.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsFixedArray">
            <summary>Fixed array of item at time of resolve, newly registered/removed services won't be listed.</summary>
        </member>
        <member name="T:DryIoc.IsRegistryChangePermitted">
            <summary>Controls the registry change</summary>
        </member>
        <member name="F:DryIoc.IsRegistryChangePermitted.Permitted">
            <summary>Change is permitted - the default setting</summary>
        </member>
        <member name="F:DryIoc.IsRegistryChangePermitted.Error">
            <summary>Throws the error for the new registration</summary>
        </member>
        <member name="F:DryIoc.IsRegistryChangePermitted.Ignored">
            <summary>Ignores the next registration</summary>
        </member>
        <member name="T:DryIoc.ServiceDetails">
            <summary>Provides optional service resolution details: service key, required service type, what return when service is unresolved,
            default value if service is unresolved, custom service value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Default">
            Default details if not specified, use default setting values, e.g. <see cref="F:DryIoc.IfUnresolved.Throw"/>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefault">
            Default details with <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> option.
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered">
            Default details with <see cref="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered"/> option.
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(DryIoc.IfUnresolved)">
            <summary>Creates new details out of provided settings, or returns default if all settings have default value.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates new details out of provided settings, or returns default if all settings have default value.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Object)">
            <summary>Sets custom value for service. This setting is orthogonal to the rest.
            Using default value with invalid ifUnresolved.Throw option to indicate custom value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.RequiredServiceType">
            <summary>Service type to search in registry. Should be assignable to user requested service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.ServiceKey">
            <summary>Service key provided with registration.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Metadata">
            <summary>Metadata value to find in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.HasCustomValue">
            <summary>Indicates that the custom value is specified.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails._value">
            <summary>Either default or custom value depending on <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> setting.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.DefaultValue">
            <summary>Value to use in case <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is set to not Throw.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.CustomValue">
            <summary>Custom value specified for dependency. The IfUnresolved.Throw is the marker of custom value comparing to default value.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.ToString">
            <summary>Pretty prints service details to string for debugging and errors.</summary> <returns>Details string.</returns>
        </member>
        <member name="M:DryIoc.ServiceDetails.Equals(DryIoc.ServiceDetails)">
            <summary>Check all property for the equality</summary>
        </member>
        <member name="T:DryIoc.ServiceInfoTools">
            <summary>Contains tools for combining or propagating of <see cref="T:DryIoc.ServiceInfo"/> independent of its concrete implementations.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithType(DryIoc.ServiceInfo,System.Type)">
            <summary>Creates service info with new type but keeping the details.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithIfUnresolved(DryIoc.ServiceInfo,DryIoc.IfUnresolved)">
            <summary>Creates new info with new IfUnresolved behavior or returns the original info if behavior is not different,
            or the passed info is not a <see cref="F:DryIoc.ServiceDetails.HasCustomValue"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithDetails``1(``0,DryIoc.ServiceDetails)">
            <summary>Combines service info with details. The main goal is to combine service and required service type.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(DryIoc.ServiceInfo,System.Type,DryIoc.ServiceDetails,DryIoc.IContainer,DryIoc.FactoryType)">
            <summary>Enables propagation/inheritance of info between dependency and its owner:
            for instance <see cref="F:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(System.Type,System.Type,DryIoc.ServiceDetails,DryIoc.IContainer,DryIoc.FactoryType)">
            <summary>Enables propagation/inheritance of info between dependency and its owner:
            for instance <see cref="F:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(System.Type,DryIoc.ServiceInfo,DryIoc.IContainer,DryIoc.FactoryType)">
            <summary>Enables propagation/inheritance of info between dependency and its owner:
            for instance <see cref="F:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.GetActualServiceType(DryIoc.ServiceInfo)">
            <summary>Returns required service type if it is specified and assignable to service type,
            otherwise returns service type.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.ServiceInfo)">
            <summary>Appends info string representation into provided builder.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo">
            <summary>Represents custom or resolution root service info, there is separate representation for parameter,
            property and field dependencies.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.OfServiceAndRequiredType(System.Type,System.Type,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceType">
            <summary>Type of service, identifies the registered service in registry.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.Details">
            <summary>Additional settings. If not specified uses <see cref="F:DryIoc.ServiceDetails.Default"/>.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceKey">
            <summary>Service key provided with registration.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.IfUnresolved)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,System.Object)">
            <summary>Creates info out of the provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,System.Type,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo.Typed">
            <summary>Typed service info</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.Typed.ServiceType">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ServiceInfo.Typed.#ctor(System.Type)">
            <summary>Creates the service info</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Creates service info using typed <typeparamref name="TService"/>.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo.Typed`1">
            <summary>Strongly-typed version of Service Info.</summary> <typeparam name="TService">Service type.</typeparam>
        </member>
        <member name="P:DryIoc.ServiceInfo.Typed`1.ServiceType">
            <inheritdoc/>
        </member>
        <member name="M:DryIoc.ServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.ServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.ParameterServiceInfo">
            <summary>Provides <see cref="T:DryIoc.ServiceInfo"/> for parameter, by default using parameter type as <see cref="P:DryIoc.ServiceInfo.ServiceType"/>.</summary>
            <remarks>For parameter default setting <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is <see cref="F:DryIoc.IfUnresolved.Throw"/>.</remarks>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.ServiceType">
            <inheritdoc/>
        </member>
        <member name="F:DryIoc.ParameterServiceInfo.Parameter">
            <summary>Parameter info.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo)">
            <summary>Creates service info from parameter alone, setting service type to parameter type,
            and setting resolution policy to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> if parameter is optional.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo,System.Type,DryIoc.ServiceDetails)">
            <summary>Creates service info from the parameter, type and the details</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.ServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.Typed.ServiceType">
            <inheritdoc/>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Typed.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="T:DryIoc.PropertyOrFieldServiceInfo">
            <summary>Base class for property and field dependency info.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.#ctor(System.Type)">
            <summary>Creates the service info</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Details">
            <summary>Optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Member">
            <summary>Either <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/>.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.SetValue(System.Object,System.Object)">
            <summary>Sets property or field value on provided holder object.</summary>
            <param name="holder">Holder of property or field.</param> <param name="value">Value to set.</param>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.MemberInfo)">
            <summary>Create property or field service info out of provided member.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.PropertyInfo)">
            <summary>Create property service info out of provided property.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.OfRequiredProperty(System.Reflection.PropertyInfo)">
            <summary>Create property service info out of provided property with the details of `IfUnresolved.Throw`.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.FieldInfo)">
            <summary>Create field service info out of provided property.</summary>
        </member>
        <member name="T:DryIoc.RequestFlags">
            <summary>Stored check results of two kinds: inherited down dependency chain and not.</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.Default">
            <summary>Nothing is set</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.TracksTransientDisposable">
            <summary>Not inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsSingletonOrDependencyOfSingleton">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsWrappedInFunc">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsResolutionCall">
            <summary>Indicates that the request is the one from Resolve call.</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.OpensResolutionScope">
            <summary>Non inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.StopRecursiveDependencyCheck">
            <summary>Non inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsGeneratedResolutionDependencyExpression">
            <summary>Non inherited. Marks the expression to be added to generated resolutions to prevent infinite recursion</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsDirectlyWrappedInFunc">
            <summary>Non inherited. Indicates the root service inside the function.</summary>
        </member>
        <member name="T:DryIoc.RequestTools">
            <summary>Helper extension methods to use on the bunch of factories instead of lambdas to minimize allocations</summary>
        </member>
        <member name="M:DryIoc.RequestTools.MatchFactoryConditionAndMetadata(DryIoc.Request,DryIoc.ServiceDetails,DryIoc.Factory)">
            <summary>Matching factory condition if any and the metadata if any</summary>
        </member>
        <member name="M:DryIoc.RequestTools.MatchFactoryReuse(DryIoc.Request,DryIoc.Factory)">
            <summary>Matching things</summary>
        </member>
        <member name="M:DryIoc.RequestTools.MatchGeneratedFactory(DryIoc.Request,DryIoc.Factory)">
            <summary>Matching things</summary>
        </member>
        <member name="M:DryIoc.RequestTools.MatchGeneratedFactoryByReuseAndConditionOrNull(DryIoc.Request,DryIoc.Factory)">
            <summary>Matching things</summary>
        </member>
        <member name="T:DryIoc.Request">
            <summary>Tracks the requested service and resolved factory details in a chain of nested dependencies.</summary>
        </member>
        <member name="F:DryIoc.Request.Empty">
            <summary>Empty terminal request.</summary>
        </member>
        <member name="F:DryIoc.Request.EmptyOpensResolutionScope">
            <summary>Empty request which opens resolution scope.</summary>
        </member>
        <member name="M:DryIoc.Request.Create(DryIoc.IContainer,DryIoc.ServiceInfo,DryIoc.Request,DryIoc.RequestFlags,System.Object[])">
            <summary>Creates the Resolve request. The container initiated the Resolve is stored within request.</summary>
        </member>
        <member name="M:DryIoc.Request.CreateResolutionRoot(DryIoc.IContainer,System.Type,DryIoc.IfUnresolved)">
            <summary>Creates the Resolve request. The container initiated the Resolve is stored within request.</summary>
        </member>
        <member name="M:DryIoc.Request.Create(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.Request,DryIoc.RequestFlags,System.Object[])">
            <summary>Creates the Resolve request. The container initiated the Resolve is stored within request.</summary>
        </member>
        <member name="P:DryIoc.Request.Container">
            <summary>Available at runtime only, provides an access to container initiated the request.</summary>
        </member>
        <member name="F:DryIoc.Request.DirectParent">
            <summary>Request immediate parent.</summary>
        </member>
        <member name="F:DryIoc.Request.InputArgExprs">
            <summary>Input arguments provided with `Resolve`</summary>
        </member>
        <member name="P:DryIoc.Request.Reuse">
            <summary>Service reuse.</summary>
        </member>
        <member name="P:DryIoc.Request.SelectedConstructor">
            <summary>Constructor selected by the reflection factory</summary>
        </member>
        <member name="P:DryIoc.Request.FactoryID">
            <summary>Resolved factory ID, used to identify applied decorator.</summary>
        </member>
        <member name="P:DryIoc.Request.DecoratedFactoryID">
            <summary>ID of decorated factory in case of decorator factory type</summary>
        </member>
        <member name="P:DryIoc.Request.FactoryType">
            <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
        </member>
        <member name="F:DryIoc.Request.Flags">
            <summary>Persisted request conditions</summary>
        </member>
        <member name="F:DryIoc.Request.DependencyDepth">
            <summary>Number of nested dependencies. Set with each new Push.</summary>
        </member>
        <member name="F:DryIoc.Request.DependencyCount">
            <summary>The total dependency count</summary>
        </member>
        <member name="M:DryIoc.Request.CombineDecoratorWithDecoratedFactoryID">
            <summary>Combines decorator and <see cref="P:DryIoc.Request.DecoratedFactoryID"/></summary>
        </member>
        <member name="P:DryIoc.Request.Factory">
            <summary>Runtime known resolve factory, otherwise is <c>null</c></summary>
        </member>
        <member name="P:DryIoc.Request.ImplementationType">
            <summary>Service implementation type if known.</summary>
        </member>
        <member name="M:DryIoc.Request.WithWrappedServiceFactory(DryIoc.Factory)">
            <summary>Sets the service factory already resolved by the wrapper to save for the future factory resolution</summary>
        </member>
        <member name="P:DryIoc.Request.IsEmpty">
            <summary>Indicates that request is empty initial request.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionRoot">
            <summary>Returns true if request is First in First Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionCall">
            <summary>Returns true if request is First in Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsNestedResolutionCall">
            <summary>Not the root resolution call.</summary>
        </member>
        <member name="P:DryIoc.Request.OpensResolutionScope">
            <summary>Despite its name, returns true if request is first dependency in a service opening the scope</summary>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFunc">
            <summary>Checks if the request Or its parent is wrapped in Func. Use `IsDirectlyWrappedInFunc` for the direct Func wrapper.</summary>
        </member>
        <member name="M:DryIoc.Request.IsDirectlyWrappedInFunc">
            <summary>Checks if the request is directly wrapped in Func</summary>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFuncWithArgs">
            <summary>Checks if request has parent with service type of Func with arguments.</summary>
        </member>
        <member name="M:DryIoc.Request.GetInputArgsExpr">
            <summary>Returns expression for func arguments.</summary>
        </member>
        <member name="P:DryIoc.Request.TracksTransientDisposable">
            <summary>Indicates that requested service is transient disposable that should be tracked.</summary>
        </member>
        <member name="P:DryIoc.Request.IsSingletonOrDependencyOfSingleton">
            <summary>Indicates the request is singleton or has singleton upper in dependency chain.</summary>
        </member>
        <member name="P:DryIoc.Request.CurrentScope">
            <summary>Current scope</summary>
        </member>
        <member name="P:DryIoc.Request.SingletonScope">
            <summary>Singletons</summary>
        </member>
        <member name="P:DryIoc.Request.Rules">
            <summary>Shortcut to issued container rules.</summary>
        </member>
        <member name="P:DryIoc.Request.Made">
            <summary>(optional) Made spec used for resolving request.</summary>
        </member>
        <member name="P:DryIoc.Request.Parent">
            <summary>Returns service parent skipping wrapper if any. To get direct parent use <see cref="F:DryIoc.Request.DirectParent"/>.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceType">
            <summary>Requested service type.</summary>
        </member>
        <member name="M:DryIoc.Request.GetActualServiceType">
            <summary>Compatible required or service type.</summary>
        </member>
        <member name="M:DryIoc.Request.GetServiceDetails">
            <summary>Get the details</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceKey">
            <summary>Optional service key to identify service of the same type.</summary>
        </member>
        <member name="P:DryIoc.Request.IfUnresolved">
            <summary>Policy to deal with unresolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.RequiredServiceType">
            <summary>Required service type if specified.</summary>
        </member>
        <member name="P:DryIoc.Request.ReuseLifespan">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="M:DryIoc.Request.GetKnownImplementationOrServiceType">
            <summary>Known implementation, or otherwise actual service type.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(DryIoc.ServiceInfo,DryIoc.RequestFlags)">
            <summary>Creates new request with provided info, and links current request as a parent.
            Allows to set some additional flags. Existing/parent request should be resolved to 
            factory via `WithResolvedFactory` before pushing info into it.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Reflection.ParameterInfo,DryIoc.RequestFlags)">
            <summary>Creates new request with provided info, and links current request as a parent.
            Allows to set some additional flags. Existing/parent request should be resolved to 
            factory via `WithResolvedFactory` before pushing info into it.</summary>
        </member>
        <member name="M:DryIoc.Request.PushServiceType(System.Type,DryIoc.RequestFlags)">
            <summary>Creates new request with provided info, and links current request as a parent.
            Allows to set some additional flags. Existing/parent request should be resolved to 
            factory via `WithResolvedFactory` before pushing info into it.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.RequestFlags)">
            <summary>Composes service description into <see cref="T:DryIoc.ServiceInfo"/> and Pushes the new request.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Int32,System.Type,DryIoc.IReuse)">
            <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Int32,System.Type,DryIoc.IReuse,DryIoc.RequestFlags)">
            <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags)">
            <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags,System.Int32)">
            <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,System.String,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags,System.Int32)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.WithChangedType``1(``0,System.Func{System.Type,``0,System.Type})">
            <summary>Allow to switch current service info to the new one, e.g. in decorators</summary>
        </member>
        <member name="M:DryIoc.Request.WithIfUnresolved(DryIoc.IfUnresolved)">
            Produces the new request with the changed `ifUnresolved` or returns original request otherwise
        </member>
        <member name="M:DryIoc.Request.WithFlags(DryIoc.RequestFlags)">
            <summary>Updates the flags</summary>
        </member>
        <member name="M:DryIoc.Request.ChangeServiceKey(System.Object)">
            <summary>Sets service key to passed value. Required for multiple default services to change null key to
            actual <see cref="T:DryIoc.DefaultKey"/></summary>
        </member>
        <member name="M:DryIoc.Request.WithInputArgs(DryIoc.FastExpressionCompiler.LightExpression.Expression[])">
            <summary>Prepends input arguments to existing arguments in request. It is done because the
            nested Func/Action input argument has a priority over outer argument.
            The arguments are provided by Func and Action wrappers, or by `args` parameter in Resolve call.</summary>
        </member>
        <member name="M:DryIoc.Request.WithResolvedFactory(DryIoc.Factory,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Returns new request with set implementation details.</summary>
            <param name="factory">Factory to which request is resolved.</param>
            <param name="skipRecursiveDependencyCheck">(optional) does not check for recursive dependency.
            Use with caution. Make sense for Resolution expression.</param>
            <param name="skipCaptiveDependencyCheck">(optional) allows to skip reuse mismatch aka captive dependency check.</param>
            <param name="copyRequest">Make a defensive copy of request.</param>
            <returns>New request with set factory.</returns>
        </member>
        <member name="M:DryIoc.Request.HasRecursiveParent(System.Int32)">
            <summary>Check for the parents.</summary>
        </member>
        <member name="M:DryIoc.Request.HasRecursiveParentUntilResolutionRoot(System.Int32)">
            <summary>Check for the parents until very end.</summary>
        </member>
        <member name="M:DryIoc.Request.Is``1(System.Func{``0},System.Func{System.Reflection.ParameterInfo,``0},System.Func{System.Reflection.PropertyInfo,``0},System.Func{System.Reflection.FieldInfo,``0})">
            <summary>If request corresponds to dependency injected into parameter,
            then method calls <paramref name="parameter"/> handling and returns its result.
            If request corresponds to property or field, then method calls respective handler.
            If request does not correspond to dependency, then calls <paramref name="root"/> handler.</summary>
        </member>
        <member name="M:DryIoc.Request.GetEnumerator">
            <summary>Enumerates self and all request stack parents.</summary>
        </member>
        <member name="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints current request info only (no parents printed) to provided builder.</summary>
        </member>
        <member name="M:DryIoc.Request.Print(System.Int32)">
            <summary>Prints full stack of requests starting from current one using <see cref="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)"/>.</summary>
        </member>
        <member name="M:DryIoc.Request.ToString">
            <summary>Prints whole request chain.</summary>
        </member>
        <member name="M:DryIoc.Request.Equals(System.Object)">
            <summary>Returns true if request info and passed object are equal, and their parents recursively are equal.</summary>
        </member>
        <member name="M:DryIoc.Request.Equals(DryIoc.Request)">
            <summary>Returns true if request info and passed info are equal, and their parents recursively are equal.</summary>
        </member>
        <member name="M:DryIoc.Request.EqualsWithoutParent(DryIoc.Request)">
            <summary>Compares self properties but not the parents.</summary>
        </member>
        <member name="M:DryIoc.Request.GetHashCode">
            <summary>Calculates the combined hash code based on factory IDs.</summary>
        </member>
        <member name="M:DryIoc.Request.IsolateRequestChain">
            Severe the connection with the request pool up to the parent so that no one can change the Request state
        </member>
        <member name="T:DryIoc.FactoryType">
            <summary>Type of services supported by Container.</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Service">
            <summary>(default) Defines normal service factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Decorator">
            <summary>Defines decorator factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Wrapper">
            <summary>Defines wrapper factory.</summary>
        </member>
        <member name="T:DryIoc.Setup">
            <summary>Base class to store optional <see cref="T:DryIoc.Factory"/> settings.</summary>
        </member>
        <member name="P:DryIoc.Setup.FactoryType">
            <summary>Factory type is required to be specified by concrete setups as in
            <see cref="T:DryIoc.Setup.ServiceSetup"/>, <see cref="T:DryIoc.Setup.DecoratorSetup"/>, <see cref="T:DryIoc.Setup.WrapperSetup"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.Condition">
            <summary>Predicate to check if factory could be used for resolved request.</summary>
        </member>
        <member name="P:DryIoc.Setup.DisposalOrder">
            <summary>Relative disposal order when defined. Greater number, later dispose.</summary>
        </member>
        <member name="P:DryIoc.Setup.Metadata">
            <summary>Arbitrary metadata object associated with Factory/Implementation, may be a dictionary of key-values.</summary>
        </member>
        <member name="M:DryIoc.Setup.MatchesMetadata(System.String,System.Object)">
            <summary>Returns true if passed meta key and value match the setup metadata.</summary>
        </member>
        <member name="M:DryIoc.Setup.GetMetadataValueMatchedByMetadataType(System.Type)">
            <summary>Retrieve the whole metadata object matched to the type or value from the metadata dictionary matched by the type</summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCall">
            <summary>Indicates that injected expression should be:
            <c><![CDATA[r.Resolver.Resolve<IDependency>(...)]]></c>
            instead of: <c><![CDATA[new Dependency(...)]]></c></summary>
        </member>
        <member name="F:DryIoc.Setup.AsResolutionCallSetup">
            <summary>Setup with the only setting of `AsResolutionCall</summary>` 
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCallForExpressionGeneration">
            <summary>Works as `AsResolutionCall` but only with `Rules.UsedForExpressionGeneration`</summary>
        </member>
        <member name="F:DryIoc.Setup.AsResolutionCallForGeneratedExpressionSetup">
            <summary>Specifies to use `asResolutionCall` but only in expression generation context, e.g. for compile-time generation</summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionRoot">
            <summary>Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Setup.OpenResolutionScope">
            <summary>Opens scope, also implies <see cref="P:DryIoc.Setup.AsResolutionCall"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.WeaklyReferenced">
            <summary>Stores reused instance as WeakReference.</summary>
        </member>
        <member name="P:DryIoc.Setup.AllowDisposableTransient">
            <summary>Allows registering transient disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.TrackDisposableTransient">
            <summary>Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</summary>
        </member>
        <member name="P:DryIoc.Setup.UseParentReuse">
            <summary>Instructs to use parent reuse. Applied only if <see cref="P:DryIoc.Factory.Reuse"/> is not specified.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreventDisposal">
            <summary>Prevents disposal of reused instance if it is disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreferInSingleServiceResolve">
            <summary>When single service is resolved, but multiple candidates found, this setting will be used to prefer this one.</summary>
        </member>
        <member name="P:DryIoc.Setup.AvoidResolutionScopeTracking">
            <summary>Does not add the resolution scope into the parent or singleton scope,
            preventing possibly unwanted holding of the scope (and its services) for the lifespan of the container.</summary>
        </member>
        <member name="F:DryIoc.Setup.Default">
            <summary>Default setup for service factories.</summary>
        </member>
        <member name="M:DryIoc.Setup.With(System.Object,System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            <summary>Constructs setup object out of specified settings.
            If all settings are default then <see cref="F:DryIoc.Setup.Default"/> setup will be returned.
            <paramref name="metadataOrFuncOfMetadata"/> is metadata object or Func returning metadata object.
            <paramref name="avoidResolutionScopeTracking"/>Does not add the resolution scope into the parent or singleton scope,
            preventing possibly unwanted holding of the scope (and its services) for the lifespan of the container.</summary>
        </member>
        <member name="F:DryIoc.Setup.Wrapper">
            <summary>Default setup which will look for wrapped service type as single generic parameter.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperWith(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean)">
            <summary>Returns generic wrapper setup.
            Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
            Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
            when generic wrapper type arguments should be ignored.</summary>
        </member>
        <member name="F:DryIoc.Setup.Decorator">
            <summary>Default decorator setup: decorator is applied to service type it registered with.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorWith(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>Creates setup with optional condition.
            The <paramref name="order" /> specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</summary>
        </member>
        <member name="M:DryIoc.Setup.GetDecorateeCondition(System.Type,System.Object,System.Func{DryIoc.Request,System.Boolean})">
            Creates a condition for both <paramref name="decorateeType"/>, <paramref name="decorateeServiceKey"/> and additional condition
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf(System.Type,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Object)">
            <summary>Setup for decorator of type <paramref name="decorateeType"/>.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf``1(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Object)">
            <summary>Setup for decorator of type <typeparamref name="TDecoratee"/>.</summary>
        </member>
        <member name="T:DryIoc.Setup.ServiceSetup">
            <summary>Service setup.</summary>
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.FactoryType">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.Metadata">
            <summary>Evaluates metadata if it specified as Func of object, and replaces Func with its result, otherwise just returns metadata object.</summary>
            <remarks>Invocation of Func metadata is Not thread-safe. Please take care of that inside the Func.</remarks>
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor">
            All settings are set to the default.
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Object,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            Specify all the individual settings.
        </member>
        <member name="T:DryIoc.Setup.WrapperSetup">
            <summary>Setup applied for wrappers.</summary>
        </member>
        <member name="P:DryIoc.Setup.WrapperSetup.FactoryType">
            <summary>Returns <see cref="F:DryIoc.FactoryType.Wrapper"/> type.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.WrappedServiceTypeArgIndex">
            <summary>Delegate to get wrapped type from provided wrapper type.
            If wrapper is generic, then wrapped type is usually a generic parameter.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.AlwaysWrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.Unwrap">
            <summary>Delegate returning wrapped type from wrapper type. Overwrites other options.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32)">
            <summary>Default setup</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument.
            Need to be set for multiple type arguments.</param>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>Returns generic wrapper setup.
            Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
            Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
            when generic wrapper type arguments should be ignored.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.GetWrappedTypeOrNullIfWrapsRequired(System.Type)">
            <summary>Unwraps service type or returns the <paramref name="serviceType"/> as-is.</summary>
        </member>
        <member name="T:DryIoc.Setup.DecoratorSetup">
            <summary>Setup applied to decorators.</summary>
        </member>
        <member name="P:DryIoc.Setup.DecoratorSetup.FactoryType">
            <summary>Returns Decorator factory type.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.Order">
            <summary>If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.UseDecorateeReuse">
            <summary>Instructs to use decorated service reuse. Decorated service may be decorator itself.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor">
            <summary>Default setup.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>Creates decorator setup with optional condition. <paramref name="condition" /> applied to 
            decorated service to find that service is the decorator target. <paramref name="order" /> specifies 
            relative decorator position in decorators chain. Greater number means further from decoratee -
            specify negative number to stay closer. Decorators without order (Order is 0) or with equal order
            are applied in registration order - first registered are closer decoratee.</summary>
        </member>
        <member name="T:DryIoc.FactoryFlags">
            <summary>Flags to describe how to deal with factory result expression</summary>
        </member>
        <member name="F:DryIoc.FactoryFlags.Default">
            <summary>Up to DryIoc to decide</summary>
        </member>
        <member name="F:DryIoc.FactoryFlags.PleaseDontSetDoNotCache">
            <summary>Prevents DryIoc to set `DoNotCache`</summary>
        </member>
        <member name="F:DryIoc.FactoryFlags.DoNotCache">
            <summary>If set, the expression won't be cached</summary> 
        </member>
        <member name="F:DryIoc.FactoryFlags.AsResolutionCall">
            <summary>If set then as resolution cache, it is for the internal use complementing the Setup.IsResolutionCall</summary>
        </member>
        <member name="T:DryIoc.Factory">
            <summary>Base class for different ways to instantiate service:
            <list type="bullet">
            <item>Through reflection - <see cref="T:DryIoc.ReflectionFactory"/></item>
            <item>Using custom delegate - <see cref="T:DryIoc.DelegateFactory"/></item>
            <item>Using custom expression - <see cref="T:DryIoc.ExpressionFactory"/></item>
            <item>A placeholder for future actual implementation - <see cref="T:DryIoc.FactoryPlaceholder"/></item>
            </list>
            For all of the types Factory should provide result as <see cref="T:DryIoc.FastExpressionCompiler.LightExpression.Expression"/> and <see cref="T:DryIoc.FactoryDelegate"/>.
            Factories are supposed to be immutable and stateless.
            Each created factory has an unique ID set in <see cref="P:DryIoc.Factory.FactoryID"/>.</summary>
        </member>
        <member name="M:DryIoc.Factory.GetNextID">
            <summary>Get next factory ID in a atomic way.</summary><returns>The ID.</returns>
        </member>
        <member name="P:DryIoc.Factory.FactoryID">
            <summary>Unique factory id generated from static seed.</summary>
        </member>
        <member name="P:DryIoc.Factory.Reuse">
            <summary>Reuse policy for created services. The default is `null` which means the absense of the resue or Transient</summary>
        </member>
        <member name="P:DryIoc.Factory.Setup">
            <summary>Setup may contain different/non-default factory settings.</summary>
        </member>
        <member name="P:DryIoc.Factory.Flags">
            <summary>Indicates how to deal with the result expression</summary>
        </member>
        <member name="P:DryIoc.Factory.CanCache">
            <summary>Can cache the result expression</summary>
        </member>
        <member name="M:DryIoc.Factory.DoNotCache">
            <summary>Instructs to skip caching the factory unless it really wants to do so via `PleaseDontSetDoNotCache`</summary>
        </member>
        <member name="M:DryIoc.Factory.CheckCondition(DryIoc.Request)">
            <summary>Checks that condition is met for request or there is no condition setup.</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryType">
            <summary>Shortcut for <see cref="P:DryIoc.Setup.FactoryType"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.ImplementationType">
            <summary>Non-abstract closed implementation type. May be null if not known beforehand, e.g. in <see cref="T:DryIoc.DelegateFactory"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.CanAccessImplementationType">
            <summary>Allow inheritors to define lazy implementation type</summary>
        </member>
        <member name="P:DryIoc.Factory.RegistrationOrder">
            <summary>Registration order.</summary>
        </member>
        <member name="P:DryIoc.Factory.Made">
            <summary>Settings <b>(if any)</b> to select Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="P:DryIoc.Factory.HasRuntimeState">
            <summary>The factory inserts the runtime-state into result expression, e.g. delegate or pre-created instance.</summary>
        </member>
        <member name="P:DryIoc.Factory.AsResolutionCall">
            <summary>Factory expression should be the resolution call</summary>
        </member>
        <member name="P:DryIoc.Factory.GeneratedFactories">
            <summary>Closed generic factories</summary> 
        </member>
        <member name="P:DryIoc.Factory.GeneratorFactory">
            <summary>Open-generic parent factory</summary> 
        </member>
        <member name="M:DryIoc.Factory.GetGeneratedFactoryOrDefault(DryIoc.Request,System.Boolean)">
            <summary>Returns the closed-generic generated factory or `null`</summary>
        </member>
        <member name="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The main factory method to create a service expression, e.g. "new Client(new Service())".
            If <paramref name="request"/> has <see cref="F:DryIoc.Request.InputArgExprs"/> specified, they could be used in expression.</summary>
        </member>
        <member name="M:DryIoc.Factory.CreateExpressionWithWrappedFactory(DryIoc.Request,DryIoc.Factory)">
            <summary>The method is the optimization, its behavior should be the same as the `CreateExpressionOrDefault`.
            It accepts the service factory found by the collection or higher wrapper.
            Here in the default implementation we just ignoring the passed factory.</summary>
        </member>
        <member name="M:DryIoc.Factory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Returns service expression: either by creating it with <see cref="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)"/> or taking expression from cache.
            Before returning method may transform the expression  by applying <see cref="P:DryIoc.Factory.Reuse"/>, or/and decorators if found any.</summary>
        </member>
        <member name="M:DryIoc.Factory.ApplyReuse(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.Request)">
            <summary>Applies reuse to created expression, by wrapping passed expression into scoped access
            and producing the result expression.</summary>
        </member>
        <member name="M:DryIoc.Factory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>Creates factory delegate from service expression and returns it.</summary>
        </member>
        <member name="M:DryIoc.Factory.ToString">
            <summary>Returns nice string representation of factory.</summary>
        </member>
        <member name="T:DryIoc.FactoryMethodSelector">
            <summary>Declares delegate to get single factory method or constructor for resolved request.</summary>
        </member>
        <member name="T:DryIoc.ParameterSelector">
            <summary>Specifies how to get parameter info for injected parameter and resolved request</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFieldsSelector">
            <summary>Specifies what properties or fields to inject and how.</summary>
        </member>
        <member name="T:DryIoc.Parameters">
            <summary>DSL for specifying <see cref="T:DryIoc.ParameterSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.Parameters.Of">
            <summary>Returns default service info wrapper for each parameter info.</summary>
        </member>
        <member name="F:DryIoc.Parameters.IfUnresolvedReturnDefault">
            <summary>Returns service info which considers each parameter as optional.</summary>
        </member>
        <member name="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Combines source selector with other. Other is used as fallback when source returns null.</summary>
        </member>
        <member name="M:DryIoc.Parameters.And(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Obsolete: please use <see cref="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)"/></summary>
        </member>
        <member name="M:DryIoc.Parameters.Details(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Overrides source parameter rules with specific parameter details. 
            If it is not your parameter just return null.</summary>
            <param name="source">Original parameters rules</param>
            <param name="getDetailsOrNull">Should return specific details or null.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Position(DryIoc.ParameterSelector,System.Int32,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="position"/>.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Position(DryIoc.ParameterSelector,System.Int32,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="position"/>
            and apply the specified service details..</summary>
        </member>
        <member name="M:DryIoc.Parameters.Position(DryIoc.ParameterSelector,System.Int32,System.Func{DryIoc.Request,System.Object})">
            <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="position"/>
            and assign the custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="name"/>.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Name to identify parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Specify parameter by name and apply the specified service details.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by name and assign the custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <paramref name="parameterType"/>.</summary>
            <param name="source">Source selector.</param> <param name="parameterType">The type of the parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <typeparamref name="T"/>.</summary>
            <typeparam name="T">Type of parameter.</typeparam> <param name="source">Source selector.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Specify parameter by type and set its details.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,``0})">
            <summary>Specify parameter by type and set custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by type and set custom value to it.</summary>
            <param name="source">Original parameters rules.</param>
            <param name="parameterType">The type of the parameter.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFields">
            <summary>DSL for specifying <see cref="T:DryIoc.PropertiesAndFieldsSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Of">
            <summary>Say to not resolve any properties or fields.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Auto">
            <summary>Public assignable instance members of any type except object, string, primitives types, and arrays of those.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Properties(System.Boolean,System.Boolean,DryIoc.IfUnresolved)">
            <summary>Public, declared, assignable, non-primitive properties.</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFields.GetServiceInfo">
            <summary>Should return service info for input member (property or field).</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.All(System.Boolean,System.Boolean,System.Boolean,System.Boolean,DryIoc.IfUnresolved,DryIoc.PropertiesAndFields.GetServiceInfo)">
            <summary>Generates selector property and field selector with settings specified by parameters.
            If all parameters are omitted the return all public not primitive members.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Combines source properties and fields with other. Other will override the source condition.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Obsolete: please use <see cref="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/></summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Details(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,DryIoc.ServiceDetails})">
            <summary>Specifies service details (key, if-unresolved policy, required type) for property/field with the name.</summary>
            <param name="source">Original member selector.</param> <param name="name">Member name.</param> <param name="getDetails">Details.</param>
            <returns>New selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for property/field identified by <paramref name="name"/>.</summary>
            <param name="source">Source selector.</param> <param name="name">Name to identify member.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default returns default value if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specifies custom value for property/field with specific name.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if property matches flags provided.</summary>
            <param name="property">Property to match</param>
            <param name="withNonPublic">Says to include non public properties.</param>
            <param name="withPrimitive">Says to include properties of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.FieldInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if field matches flags provided.</summary>
            <param name="field">Field to match.</param>
            <param name="withNonPublic">Says to include non public fields.</param>
            <param name="withPrimitive">Says to include fields of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="T:DryIoc.ReflectionFactory">
            <summary>Reflects on <see cref="P:DryIoc.ReflectionFactory.ImplementationType"/> constructor parameters and members,
            creates expression for each reflected dependency, and composes result service expression.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.ImplementationType">
            <summary>Non-abstract service implementation type. May be open generic.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.CanAccessImplementationType">
            <summary>Is `true` for `null` or some implementation type, but is `false` below in `WithAllDetails` for the type provider</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.Made">
            <summary>Injection rules set for Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.RegistrationOrder">
            <summary>Will contain factory ID of generator's factory for generated factory.</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.Of(System.Type)">
            <summary>Creates the memory-optimized factory based on arguments</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.Of(System.Type,DryIoc.IReuse)">
            <summary>Creates the memory-optimized factory based on arguments</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.Of(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates the memory-optimized factory based on arguments</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.Of(System.Func{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates the factory based on arguments</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor">
            <summary>Required for the `WithAllDetails` factory below</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Type)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.WithAllDetails.GeneratedFactories">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.ReflectionFactory.WithAllDetails.GeneratorFactory">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ReflectionFactory.WithAllDetails.GetGeneratedFactoryOrDefault(DryIoc.Request,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ReflectionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression.</summary>
        </member>
        <member name="T:DryIoc.ExpressionFactory">
            <summary>Creates service expression using client provided expression factory delegate.</summary>
        </member>
        <member name="P:DryIoc.ExpressionFactory.Reuse">
            <inheritdoc/>
        </member>
        <member name="P:DryIoc.ExpressionFactory.Setup">
            <inheritdoc/>
        </member>
        <member name="M:DryIoc.ExpressionFactory.#ctor(System.Func{DryIoc.Request,DryIoc.FastExpressionCompiler.LightExpression.Expression},DryIoc.IReuse,DryIoc.Setup)">
            <summary>Constructor</summary>
        </member>
        <member name="M:DryIoc.ExpressionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <inheritdoc/>
        </member>
        <member name="T:DryIoc.WrapperExpressionFactory">
            <summary>Creates service expression using client provided expression factory delegate.
            Important! that it may use the already resolved service factory unwrapped by the higher wrapper</summary>
        </member>
        <member name="M:DryIoc.WrapperExpressionFactory.Of(System.Func{DryIoc.Request,DryIoc.Factory,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <summary>Creates the factory out of provided delegate producing the expression based on the request</summary>
        </member>
        <member name="M:DryIoc.WrapperExpressionFactory.Of(System.Func{DryIoc.Request,DryIoc.Factory,DryIoc.FastExpressionCompiler.LightExpression.Expression},DryIoc.Setup)">
            <summary>Creates the factory out of provided delegate producing the expression based on the request, and the setup</summary>
        </member>
        <member name="M:DryIoc.WrapperExpressionFactory.Of(System.Func{DryIoc.Request,DryIoc.Factory,DryIoc.FastExpressionCompiler.LightExpression.Expression},DryIoc.IReuse,DryIoc.Setup)">
            <summary>Creates the factory out of provided delegate producing the expression based on the request, and the setup and/or setup</summary>
        </member>
        <member name="P:DryIoc.WrapperExpressionFactory.Setup">
            <inheritdoc/>
        </member>
        <member name="M:DryIoc.WrapperExpressionFactory.#ctor(System.Func{DryIoc.Request,DryIoc.Factory,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <summary>Constructor</summary>
        </member>
        <member name="M:DryIoc.WrapperExpressionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <inheritdoc/>
        </member>
        <member name="M:DryIoc.WrapperExpressionFactory.CreateExpressionWithWrappedFactory(DryIoc.Request,DryIoc.Factory)">
            <inheritdoc/>
        </member>
        <member name="T:DryIoc.InstanceFactory">
            <summary>Wraps the instance in registry</summary>
        </member>
        <member name="F:DryIoc.InstanceFactory.Instance">
            <summary>The registered pre-created object instance</summary>
        </member>
        <member name="P:DryIoc.InstanceFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="P:DryIoc.InstanceFactory.Reuse">
            <inheritdoc/>
        </member>
        <member name="P:DryIoc.InstanceFactory.Setup">
            <inheritdoc/>
        </member>
        <member name="P:DryIoc.InstanceFactory.HasRuntimeState">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.InstanceFactory.Of(System.Object)">
            <summary>Creates the memory-optimized factory from the supplied arguments</summary>
        </member>
        <member name="M:DryIoc.InstanceFactory.Of(System.Object,DryIoc.Setup)">
            <summary>Creates the memory-optimized factory from the supplied arguments</summary>
        </member>
        <member name="M:DryIoc.InstanceFactory.#ctor(System.Object)">
            <summary>Creates the factory.</summary>
        </member>
        <member name="M:DryIoc.InstanceFactory.ValidateAndNormalizeRegistration(System.Type,System.Object,System.Boolean,DryIoc.Rules,System.Boolean)">
            Simplified specially for the register instance 
        </member>
        <member name="M:DryIoc.InstanceFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Wraps the instance in expression constant</summary>
        </member>
        <member name="M:DryIoc.InstanceFactory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Simplified path for the registered instance</summary>
        </member>
        <member name="M:DryIoc.InstanceFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>Used at resolution root too simplify getting the actual instance</summary>
        </member>
        <member name="T:DryIoc.DelegateFactory">
            <summary>This factory is the thin wrapper for user provided delegate
            and where possible it uses delegate directly: without converting it to expression.</summary>
        </member>
        <member name="P:DryIoc.DelegateFactory.HasRuntimeState">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.DelegateFactory.Setup">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.DelegateFactory.Of(DryIoc.FactoryDelegate)">
            <summary>Creates the memory-optimized factory from the provided arguments</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.Of(DryIoc.FactoryDelegate,DryIoc.IReuse)">
            <summary>Creates the memory-optimized factory from the provided arguments</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.Of(DryIoc.FactoryDelegate,DryIoc.Setup)">
            <summary>Creates the memory-optimized factory from the provided arguments</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.Of(DryIoc.FactoryDelegate,DryIoc.IReuse,DryIoc.Setup)">
            <summary>Creates the memory-optimized factory from the provided arguments</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.#ctor(DryIoc.FactoryDelegate)">
            <summary>Creates the factory.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Create expression by wrapping call to stored delegate with provided request.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>If possible returns delegate directly, without creating expression trees, just wrapped in <see cref="T:DryIoc.FactoryDelegate"/>.
            If decorator found for request then factory fall-backs to expression creation.</summary>
            <param name="request">Request to resolve.</param>
            <returns>Factory delegate directly calling wrapped delegate, or invoking expression if decorated.</returns>
        </member>
        <member name="T:DryIoc.FactoryPlaceholder">
            <summary>The placeholder for thr later resgitration</summary>
        </member>
        <member name="F:DryIoc.FactoryPlaceholder.Default">
            <summary>May be used in places where placeholder is needed</summary>
        </member>
        <member name="P:DryIoc.FactoryPlaceholder.Setup">
            <summary> Always resolved asResolutionCall, to create a hole in object graph to be filled-in later by the runtime container</summary>
        </member>
        <member name="P:DryIoc.FactoryPlaceholder.Reuse">
            <summary>Explicit Transient reuse to avoid captive dependency error, e.g. if the Rules.Default reuse is Singleton</summary>
        </member>
        <member name="M:DryIoc.FactoryPlaceholder.CreateExpressionOrDefault(DryIoc.Request)">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.InjectedIntoFactoryDummy.Reuse">
            Explicit Transient reuse to avoid captive dependency error, e.g. if the Rules.Default reuse is Singleton
        </member>
        <member name="T:DryIoc.CreateScopedValue">
            Should return value stored in scope
        </member>
        <member name="T:DryIoc.IScope">
            <summary>Lazy object storage that will create object with provided factory on first access,
            then will be returning the same object for subsequent access.</summary>
        </member>
        <member name="P:DryIoc.IScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.IsDisposed">
            <summary>True if scope is disposed.</summary>
        </member>
        <member name="M:DryIoc.IScope.TryGet(System.Object@,System.Int32)">
            <summary>Looks up for stored item by id.</summary>
        </member>
        <member name="M:DryIoc.IScope.GetOrAddViaFactoryDelegate(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext)">
            Create the value via `FactoryDelegate` passing the `IResolverContext`
        </member>
        <member name="M:DryIoc.IScope.GetOrAddViaFactoryDelegateWithDisposalOrder(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext,System.Int32)">
            Create the value via `FactoryDelegate` passing the `IResolverContext`
        </member>
        <member name="M:DryIoc.IScope.TryGetOrAddWithoutClosure(System.Int32,DryIoc.IResolverContext,DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Func{DryIoc.IResolverContext,DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Object},System.Int32)">
            Creates, stores, and returns created item
        </member>
        <member name="M:DryIoc.IScope.TrackDisposable``1(``0,System.Int32)">
            <summary>Tracked item will be disposed with the scope. Smaller <paramref name="disposalOrder"/> will be disposed first.</summary>
        </member>
        <member name="M:DryIoc.IScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets or adds the service item directly to the scope services</summary>
        </member>
        <member name="M:DryIoc.IScope.SetUsed(System.Int32,System.Type,System.Object)">
            <summary>Sets (replaces) the used instance factory for the specified type.</summary>
        </member>
        <member name="M:DryIoc.IScope.TryGetUsed(System.Int32,System.Type,System.Object@)">
            <summary>Try to retrieve factory or instance (wrapped in factory) via the Use method.</summary>
        </member>
        <member name="M:DryIoc.IScope.Clone(System.Boolean)">
            <summary>The method will clone the scope factories and already created services,
            but may or may not drop the disposables thus ensuring that only the new disposables added in clone will be disposed</summary>
        </member>
        <member name="T:DryIoc.ScopeTools">
            <summary>Extension methods for scope</summary>
        </member>
        <member name="M:DryIoc.ScopeTools.Clone(DryIoc.IScope)">
            <summary>The method will clone the scope factories and already created services, including the tracked disposables</summary>
        </member>
        <member name="M:DryIoc.ScopeTools.IsUsed(DryIoc.IScope,System.Type)">
            <summary>Check if the service instance or factory is set to the scope</summary>
        </member>
        <member name="M:DryIoc.ScopeTools.UseFactory(DryIoc.IScope,System.Type,DryIoc.FactoryDelegate)">
            <summary>Sets (replaces) instance to the scope</summary>
        </member>
        <member name="M:DryIoc.ScopeTools.UseFactory``1(DryIoc.IScope,DryIoc.FactoryDelegate)">
            <summary>Sets (replaces) instance to the scope</summary>
        </member>
        <member name="M:DryIoc.ScopeTools.Use(DryIoc.IScope,System.Type,System.Object)">
            <summary>Sets (replaces) instance in the scope</summary>
        </member>
        <member name="M:DryIoc.ScopeTools.Use``1(DryIoc.IScope,System.Object)">
            <summary>Sets (replaces) instance in the scope</summary>
        </member>
        <member name="T:DryIoc.Scope">
            <summary>
            Scope is container to hold the shared per scope items and dispose <see cref="T:System.IDisposable"/> items.
            Scope uses Locking to ensure that the object factory called only once.
            </summary>
        </member>
        <member name="P:DryIoc.Scope.Parent">
            <summary>Parent scope in scope stack. Null for the root scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.Name">
            <summary>Optional name associated with scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.IsDisposed">
            <summary>True if scope is disposed.</summary>
        </member>
        <member name="M:DryIoc.Scope.Of(DryIoc.IScope,System.Object)">
            <summary>Creating</summary>
        </member>
        <member name="M:DryIoc.Scope.Of(DryIoc.IScope)">
            <summary>Creating</summary>
        </member>
        <member name="M:DryIoc.Scope.Of(System.Object)">
            <summary>Creating</summary>
        </member>
        <member name="M:DryIoc.Scope.#ctor">
            <summary>Creates scope with optional parent and name.</summary>
        </member>
        <member name="M:DryIoc.Scope.#ctor(DryIoc.ImTools.ImMap{System.Object}[],DryIoc.ImTools.ImHashMap{System.Type,System.Object},DryIoc.ImTools.ImMap{DryIoc.ImTools.ImList{System.IDisposable}})">
            <summary>The basic constructor</summary>
        </member>
        <member name="M:DryIoc.Scope.Clone(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.GetOrAddViaFactoryDelegate(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.GetOrAddViaFactoryDelegateWithDisposalOrder(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext,System.Int32)">
            <inheritdoc />
        </member>
        <member name="F:DryIoc.Scope.WaitForScopedServiceIsCreatedTimeoutTicks">
            <summary>The amount of time to wait for the other party to create the scoped (or singleton) service.</summary>
        </member>
        <member name="M:DryIoc.Scope.TryGetOrAddWithoutClosure(System.Int32,DryIoc.IResolverContext,DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Func{DryIoc.IResolverContext,DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Object},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.SetOrAdd(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TryGet(System.Object@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TrackDisposable``1(``0,System.Int32)">
            <summary>Can be used to manually add service for disposal</summary>
        </member>
        <member name="M:DryIoc.Scope.SetUsed(System.Int32,System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TryGetUsed(System.Int32,System.Type,System.Object@)">
            <summary>Try retrieve the used instance from the scope.</summary>
        </member>
        <member name="M:DryIoc.Scope.GetEnumerator">
            <summary>Enumerates all the parent scopes upwards starting from this one.</summary>
        </member>
        <member name="M:DryIoc.Scope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and empties item storage.
            The disposal happens in REVERSE resolution / injection order, consumer first, dependency next.
            It will allow consumer to do something with its dependency before it is disposed.</summary>
            <remarks>All disposal exceptions are swallowed except the ContainerException,
            which may indicate container misconfiguration.</remarks>
        </member>
        <member name="M:DryIoc.Scope.ToString">
            <summary>Prints scope info (name and parent) to string for debug purposes.</summary>
        </member>
        <member name="T:DryIoc.SetCurrentScopeHandler">
            <summary>Delegate to get new scope from old/existing current scope.</summary>
            <param name="oldScope">Old/existing scope to change.</param>
            <returns>New scope or old if do not want to change current scope.</returns>
        </member>
        <member name="T:DryIoc.IScopeContext">
            <summary>Provides ambient current scope and optionally scope storage for container,
            examples are HttpContext storage, Execution context, Thread local.</summary>
        </member>
        <member name="M:DryIoc.IScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.IScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and
            should return new current scope.</summary>
            <param name="setCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. So it is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="T:DryIoc.ThreadScopeContext">
            <summary>Tracks one current scope per thread, so the current scope in different tread would be different or null,
            if not yet tracked. Context actually stores scope references internally, so it should be disposed to free them.</summary>
        </member>
        <member name="F:DryIoc.ThreadScopeContext.ScopeContextName">
            <summary>Provides static name for context. It is OK because its constant.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope in calling Thread or null, if no scope tracked.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Change current scope for the calling Thread.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.Dispose">
            <summary>Disposes the scopes and empties internal scope storage.</summary>
        </member>
        <member name="T:DryIoc.IReuse">
            <summary>Simplified scope agnostic reuse abstraction. More easy to implement,
             and more powerful as can be based on other storage beside reuse.</summary>
        </member>
        <member name="P:DryIoc.IReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.IReuse.Name">
            <summary>Optional name. Use to find matching scope by the name.
            It also may be interpreted as object[] Names for matching with multiple scopes </summary>
        </member>
        <member name="M:DryIoc.IReuse.CanApply(DryIoc.Request)">
            <summary>Returns true if reuse can be applied: may check if scope or other reused item storage is present.</summary>
        </member>
        <member name="M:DryIoc.IReuse.Apply(DryIoc.Request,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Returns composed expression.</summary>
        </member>
        <member name="T:DryIoc.SingletonReuse">
            <summary>Returns container bound scope for storing singleton objects.</summary>
        </member>
        <member name="F:DryIoc.SingletonReuse.DefaultLifespan">
            <summary>Big lifespan.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Name">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.CanApply(DryIoc.Request)">
            <summary>Returns true because singleton is always available.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.Apply(DryIoc.Request,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Returns expression call to GetOrAddItem.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.ToExpression(System.Func{System.Object,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.ToString">
            <summary>Pretty prints reuse name and lifespan</summary>
        </member>
        <member name="T:DryIoc.CurrentScopeReuse">
            <summary>Specifies that instances are created, stored and disposed together with some scope.</summary>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.DefaultLifespan">
            <summary>Less than Singleton's</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Name">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.CanApply(DryIoc.Request)">
            <summary>Returns true if scope is open and the name is matching with reuse <see cref="P:DryIoc.CurrentScopeReuse.Name"/>.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.Apply(DryIoc.Request,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates scoped item creation and access expression.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToExpression(System.Func{System.Object,DryIoc.FastExpressionCompiler.LightExpression.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToString">
            <summary>Pretty prints reuse to string.</summary> <returns>Reuse string.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object,System.Boolean,System.Int32)">
            <summary>Creates the reuse.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object,System.Boolean)">
            <summary>Creates the reuse optionally specifying its name.</summary>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.ScopedOrSingleton">
            <summary>Flag indicating that it is a scope or singleton.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegateWithDisposalOrder(DryIoc.IResolverContext,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedViaFactoryDelegate(DryIoc.IResolverContext,System.Boolean,System.Int32,DryIoc.FactoryDelegate)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedViaFactoryDelegateWithDisposalOrder(DryIoc.IResolverContext,System.Boolean,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetNameScopedViaFactoryDelegate(DryIoc.IResolverContext,System.Object,System.Boolean,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackScopedOrSingleton(DryIoc.IResolverContext,System.Object)">
            <summary>Tracks the Unordered disposal in the current scope or in the singleton as fallback</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackScoped(DryIoc.IResolverContext,System.Boolean,System.Object)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackNameScoped(DryIoc.IResolverContext,System.Object,System.Boolean,System.Object)">
            Subject
        </member>
        <member name="T:DryIoc.IScopeName">
            <summary>Abstracts way to match reuse and scope names</summary>
        </member>
        <member name="M:DryIoc.IScopeName.Match(System.Object)">
            <summary>Does the job.</summary>
        </member>
        <member name="T:DryIoc.ScopeName">
            <summary>Custom name matcher via the provided function. 
            It may be used as a negative check, e.g. to avoid cirtain scopes and proceed to search for the specific parent scope.</summary>
        </member>
        <member name="M:DryIoc.ScopeName.Of(System.Func{System.Object,System.Boolean})">
            <summary>Constucts the scope name matches based on the user-provided predicate</summary>
        </member>
        <member name="F:DryIoc.ScopeName.MatchPredicate">
            <summary>The match precicate</summary>
        </member>
        <member name="M:DryIoc.ScopeName.Match(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.CompositeScopeName">
            <summary>Represents multiple names</summary>
        </member>
        <member name="M:DryIoc.CompositeScopeName.Of(System.Object[])">
            <summary>Wraps multiple names</summary>
        </member>
        <member name="M:DryIoc.CompositeScopeName.Match(System.Object)">
            <summary>Matches all the name in a loop until first match is found, otherwise returns false.</summary>
        </member>
        <member name="T:DryIoc.ResolutionScopeName">
            <summary>Holds the name for the resolution scope.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Of(System.Type,System.Object)">
            <summary>Creates scope with specified service type and key</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Of``1(System.Object)">
            <summary>Creates scope with specified service type and key.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeName.ServiceType">
            <summary>Type of service opening the scope.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeName.ServiceKey">
            <summary>Optional service key of service opening the scope.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Match(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ResolutionScopeName.ToString">
            <summary>String representation for easy debugging and understood error messages.</summary>
        </member>
        <member name="T:DryIoc.Reuse">
            <summary>Specifies pre-defined reuse behaviors supported by container:
            used when registering services into container with <see cref="T:DryIoc.Registrator"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Transient">
            <summary>Synonym for absence of reuse.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Singleton">
            <summary>Specifies to store single service instance per <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Scoped">
            <summary>Scoped to the any scope - either with or without the name.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object)">
            <summary>Scoped to the scope with the specified name only. 
            The `name` may be null, so the service will be scoped to any scope.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object,System.Boolean,System.Int32)">
            <summary>Scoped to the scope with the specified name only. 
            The `name` may be null, so the service will be scoped to any scope. Specifies all the scope details</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object[])">
            <summary>Scoped to the closest scope (in scope parent hierarchy) with the name from the specified names list. 
            The `names` should no contain the `null`</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Type,System.Object)">
            <summary>[Obsolete("Use ScopedToService to prevent ambiguity with the ScopeTo(object name) where name is the Type")]</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedToService(System.Type,System.Object)">
            <summary>Scoped to the scope created by the service with the specified type and optional key</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo``1(System.Object)">
            <summary>Scoped to the scope created by the service with the specified `TService` type and `serviceKey`,
            The service should specify the creation of the scope in the registration call via `setup: Setup.With(opensResolutionScope: true)` argument.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedToService``1(System.Object)">
            <summary>Scoped to the scope created by the service with the specified type and optional key</summary>
        </member>
        <member name="F:DryIoc.Reuse.ScopedOrSingleton">
            <summary>The same as <see cref="F:DryIoc.Reuse.Scoped"/> but in case of no scope available will fallback to the <see cref="F:DryIoc.Reuse.Singleton"/> reuse</summary>
            <remarks>The <see cref="F:DryIoc.Error.DependencyHasShorterReuseLifespan"/> is applied the same way as for <see cref="F:DryIoc.Reuse.Scoped"/> reuse.</remarks>
        </member>
        <member name="F:DryIoc.Reuse.InResolutionScope">
            <summary>Obsolete: same as <see cref="F:DryIoc.Reuse.Scoped"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InCurrentScope">
            <summary>Obsolete: please use <see cref="F:DryIoc.Reuse.Scoped"/> instead.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)">
            <summary>Obsolete: please use `ScopedTo` instead.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf(System.Type,System.Object)">
            <summary>Obsolete: Please use `ScopedToService` instead.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf``1(System.Object)">
            <summary>Obsolete: Please use `ScopedToService` instead.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InThread">
            <summary>Same as Scoped but requires <see cref="T:DryIoc.ThreadScopeContext"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.WebRequestScopeName">
            <summary>A special name recognized by <see cref="F:DryIoc.Reuse.InWebRequest"/>.
            Note: The usage of the named scopes is the less performant than the unnamed ones. e.g. ASP.NET Core does not use the named scope.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InWebRequest">
            <summary>Obsolete: please prefer using `Scoped` without name instead. 
            The usage of the named scopes is the less performant than the unnamed ones. e.g. ASP.NET Core does not use the named scope.</summary>
        </member>
        <member name="T:DryIoc.IfUnresolved">
            <summary>Policy to handle unresolved service.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.Throw">
            <summary>If service is unresolved for whatever means, the Resolve will throw the respective exception.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefault">
            <summary>If service is unresolved for whatever means, the Resolve will return the default value.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered">
            <summary>If service is not registered, then the Resolve will return the default value, for the other errors it will throw.</summary>
        </member>
        <member name="T:DryIoc.IResolver">
            <summary>Declares minimal API for service resolution. 
            Resolve default and keyed is separated because of optimization for faster resolution of the former.</summary>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,DryIoc.IfUnresolved)">
            <summary>Resolves default (non-keyed) service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="ifUnresolved">Says what to do if service is unresolved.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.Request,System.Object[])">
            <summary>Resolves service instance from container.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="serviceKey">(optional) service key used for registering service.</param>
            <param name="ifUnresolved">(optional) Says what to do if service is unresolved.</param>
            <param name="requiredServiceType">(optional) Registered or wrapped service type to use instead of <paramref name="serviceType"/>,
                or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
            <param name="preResolveParent">(optional) Dependency chain info.</param>
            <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> parameter.</returns>
        </member>
        <member name="M:DryIoc.IResolver.ResolveMany(System.Type,System.Object,System.Type,DryIoc.Request,System.Object[])">
            <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
            empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with this type.</summary>
            <param name="serviceType">Return type of an service item.</param>
            <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
            <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
            <param name="preResolveParent">Dependency resolution path info.</param>
            <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
            <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
        </member>
        <member name="T:DryIoc.IfAlreadyRegistered">
            <summary>Specifies options to handle situation when registered service is already present in the registry.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed">
            <summary>Appends new default registration or throws registration with the same key.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Throw">
            <summary>Throws if default or registration with the same key is already exist.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Keep">
            <summary>Keeps old default or keyed registration ignoring new registration: ensures Register-Once semantics.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Replace">
            <summary>Replaces old registration with new one.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNewImplementation">
            <summary>Adds the new implementation or null (Made.Of),
            otherwise keeps the previous registration of the same implementation type.</summary>
        </member>
        <member name="T:DryIoc.ServiceRegistrationInfo">
            <summary>Existing registration info.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.Factory">
            <summary>Registered factory.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.ServiceType">
            <summary>Required service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.OptionalServiceKey">
            <summary>May be <c>null</c> for single default service, or <see cref="T:DryIoc.DefaultKey"/> for multiple default services.</summary>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.FactoryRegistrationOrder">
            <summary>Provides registration order across all factory registrations in container.</summary>
            <remarks>May be the same for factory registered with multiple services
            OR for closed-generic factories produced from the single open-generic registration.</remarks>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.ImplementationType">
            <summary>Implementation type if available.</summary>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.AsResolutionRoot">
            <summary>Shortcut to <see cref="P:DryIoc.Setup.AsResolutionRoot"/> property, useful to find all roots</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo">
            <summary>Shortcut to service info.</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo(System.Type)">
            <summary>Overrides the service type and pushes the original service type to required service type</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo``1">
            <summary>Overrides the service type and pushes the original service type to required service type</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.#ctor(DryIoc.Factory,System.Type,System.Object)">
            <summary>Creates info. Registration order is figured out automatically based on Factory.</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.CompareTo(DryIoc.ServiceRegistrationInfo)">
            <summary>Orders by registration</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToString">
            <summary>Pretty-prints info to string.</summary>
        </member>
        <member name="T:DryIoc.IRegistrator">
            <summary>Defines operations that for changing registry, and checking if something exist in registry.</summary>
        </member>
        <member name="P:DryIoc.IRegistrator.Rules">
            <summary>Rules for defining resolution/registration behavior throughout container.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.Register(DryIoc.Factory,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean)">
            <summary>Registers factory in registry with specified service type and key for lookup.
            Returns true if factory was added to registry, false otherwise. False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/>
            setting and already existing factory</summary>
            <param name="factory">To register.</param>
            <param name="serviceType">Service type as unique key in registry for lookup.</param>
            <param name="serviceKey">Service key as complementary lookup for the same service type.</param>
            <param name="ifAlreadyRegistered">Policy how to deal with already registered factory with same service type and key.</param>
            <param name="isStaticallyChecked">[performance] Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if expected factory is registered with specified service key and type.
            Not provided or <c>null</c> <paramref name="serviceKey"/> means to check the <paramref name="serviceType"/> 
            alone with any service key.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes factory with specified service type and key from registry and cache.
            BUT consuming services may still hold on the resolved service instance.
            The cache of consuming services may also hold on the unregistered service. Use `IContainer.ClearCache` to clear all cache.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.
            Decorator and Wrapper types are not included.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetRegisteredFactories(System.Type,System.Object,DryIoc.FactoryType)">
            <summary>Searches for registered factories by type, and key (if specified),
            and by factory type (by default uses <see cref="F:DryIoc.FactoryType.Service"/>).
            May return empty, 1 or multiple factories.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.Use(System.Type,System.Object)">
            <summary>Puts instance created via the passed factory on demand into the current or singleton scope</summary>
        </member>
        <member name="T:DryIoc.RegistrySharing">
            <summary>What to do with registrations when creating the new container from the existent one.</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.Share">
            <summary>Shares both registrations and resolution cache if any</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.CloneButKeepCache">
            <summary>Clones the registrations but preserves the resolution cache</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.CloneAndDropCache">
            <summary>Clones the registrations and drops the cache -- full reset!</summary>
        </member>
        <member name="T:DryIoc.IContainer">
            <summary>Combines registrator and resolver roles, plus rules and scope management.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope)">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container.
            If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope)">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container. If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope,System.Nullable{DryIoc.IsRegistryChangePermitted})">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container. If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional)Controls what to do with registrations: ignore or throw exception.
            Throws exception by default.</param>
            <returns>New container preserving all current container state but disallowing registrations.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ResolveFactory(DryIoc.Request)">
            <summary>Searches for requested factory in registry, and then using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/>.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory, otherwise null if <see cref="P:DryIoc.Request.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetServiceFactoryOrDefault(DryIoc.Request)">
            <summary>Searches for registered service factory and returns it, or null if not found.
            Will use <see cref="P:DryIoc.Rules.FactorySelector"/> if specified.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetAllServiceFactories(System.Type,System.Boolean)">
            <summary>Finds all registered default and keyed service factories and returns them.
            It skips decorators and wrappers.</summary>
            <param name="serviceType">Service type to look for, may be open-generic type too.</param>
            <param name="bothClosedAndOpenGenerics">(optional) For generic serviceType instructs to look for
            both closed and open-generic registrations.</param>
            <returns>Enumerable of found pairs.</returns>
            <remarks>Returned Key item should not be null - it should be <see cref="F:DryIoc.DefaultKey.Value"/>.</remarks>
        </member>
        <member name="M:DryIoc.IContainer.GetServiceRegisteredAndDynamicFactories(System.Type)">
            <summary>The method will get all service factories registered and from the dynamic registration providers (if any) for the passed `serviceType`.
            The method does not try to cache the dynamic provider factories and will be calling them every time.</summary>
        </member>
        <member name="M:DryIoc.IContainer.GetWrapperFactoryOrDefault(System.Type)">
            <summary>Searches for registered wrapper factory and returns it, or null if not found.</summary>
            <param name="serviceType">Service type to look for.</param> <returns>Found wrapper factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.IsWrapper(System.Type,System.Type)">
            <summary>Faster lookups for the type and its generic type definition in the registered Wrappers.</summary>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Type)">
            <summary>Returns all decorators registered for the service type.</summary>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Int32,System.Type)">
            <summary>Returns all decorators registered for the service type.</summary>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorExpressionOrDefault(DryIoc.Request)">
            <summary>Creates decorator expression: it could be either Func{TService,TService},
            or service expression for replacing decorators.</summary>
            <param name="request">Decorated service request.</param>
            <returns>Decorator expression.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetWrappedType(System.Type,System.Type)">
            <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
            and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
            Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type to unwrap. Method will return early if type is not generic.</param>
            <param name="requiredServiceType">Required service type or null if don't care.</param>
            <returns>Unwrapped service type in case it corresponds to registered generic wrapper, or input type in all other cases.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetWrappedType(System.Type)">
            <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
            and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
            Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
        </member>
        <member name="M:DryIoc.IContainer.GetConstantExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known items into custom expression or wraps in a constant expression.</summary>
            <param name="item">Item to convert.</param>
            <param name="itemType">(optional) Type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Throws for non-primitive and not-recognized items,
            identifying that result expression require run-time state. For compiled expression it means closure in lambda delegate.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ClearCache(System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears cache for specified service(s). But does not clear instances of already resolved/created singletons and scoped services!</summary>
            <param name="serviceType">Target service type.</param>
            <param name="factoryType">(optional) If not specified, clears cache for all <see cref="T:DryIoc.FactoryType"/>.</param>
            <param name="serviceKey">(optional) If omitted, the cache will be cleared for all registrations of <paramref name="serviceType"/>.</param>
            <returns>True if target service was found, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.IContainer.Use(System.Type,System.Object)">
            <summary>Puts instance created via the passed factory on demand into the current or singleton scope</summary>
        </member>
        <member name="T:DryIoc.LazyEnumerable`1">
            <summary>Resolves all registered services of <typeparamref name="TService"/> type on demand,
            when enumerator <see cref="M:System.Collections.IEnumerator.MoveNext"/> called. If service type is not found, empty returned.</summary>
            <typeparam name="TService">Service type to resolve.</typeparam>
        </member>
        <member name="F:DryIoc.LazyEnumerable`1.Items">
            <summary>Exposes internal items enumerable.</summary>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Wraps lazy resolved items.</summary> <param name="items">Lazy resolved items.</param>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.GetEnumerator">
            <summary>Return items enumerator.</summary> 
        </member>
        <member name="T:DryIoc.Meta`2">
            <summary>Wrapper type to box service with associated arbitrary metadata object.</summary>
            <typeparam name="T">Service type.</typeparam>
            <typeparam name="TMetadata">Arbitrary metadata object type.</typeparam>
        </member>
        <member name="F:DryIoc.Meta`2.Value">
            <summary>Value or object with associated metadata.</summary>
        </member>
        <member name="F:DryIoc.Meta`2.Metadata">
            <summary>Associated metadata object. Could be anything.</summary>
        </member>
        <member name="M:DryIoc.Meta`2.#ctor(`0,`1)">
            <summary>Boxes value and its associated metadata together.</summary>
        </member>
        <member name="T:DryIoc.ContainerException">
            <summary>Exception that container throws in case of error. Dedicated exception type simplifies
            filtering or catching container relevant exceptions from client code.</summary>
        </member>
        <member name="F:DryIoc.ContainerException.Error">
            <summary>Error code of exception, possible values are listed in <see cref="F:DryIoc.ContainerException.Error"/> class.</summary>
        </member>
        <member name="P:DryIoc.ContainerException.ErrorName">
            <summary>Simplifies the access to the error name.</summary>
        </member>
        <member name="F:DryIoc.ContainerException.CollectedExceptions">
            <summary>Many collected exceptions</summary>
        </member>
        <member name="M:DryIoc.ContainerException.Of(DryIoc.ErrorCheck,System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
            <summary>Creates exception by wrapping <paramref name="errorCode"/> and its message,
            optionally with <paramref name="innerException"/> exception.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.GetMessage(DryIoc.ErrorCheck,System.Int32)">
            <summary>Gets error message based on provided args.</summary> <param name="errorCheck"></param> <param name="errorCode"></param>
        </member>
        <member name="M:DryIoc.ContainerException.Print(System.Object)">
            <summary>Prints argument for formatted message.</summary> <param name="arg">To print.</param> <returns>Printed string.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,DryIoc.ContainerException[])">
            <summary>Collects many exceptions.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String)">
            <summary>Creates exception with message describing cause and context of error.</summary>
        </member>
        <member name="F:DryIoc.ContainerException.Details">
            <summary>The optional additional exception data.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.WithDetails(System.Object,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Creates exception with details object and the message.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>Creates exception with message describing cause and context of error,
            and leading/system exception causing it.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.FormatMessage(System.String,System.String)">
            <summary>The default exception message format.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception,System.Func{System.Int32,System.String,System.Exception,System.String})">
            <summary>Allows the formatting of the final exception message.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ContainerException.TryGetDetails(DryIoc.IContainer)">
            <summary>Tries to explain the specific exception based on the passed container</summary>
        </member>
        <member name="T:DryIoc.Error">
            <summary>Defines error codes and error messages for all DryIoc exceptions (DryIoc extensions may define their own.)</summary>
        </member>
        <member name="F:DryIoc.Error.Messages">
            <summary>List of error messages indexed with code.</summary>
        </member>
        <member name="M:DryIoc.Error.NameOf(System.Int32)">
            <summary>Returns the name of error with the provided error code.</summary>
        </member>
        <member name="T:DryIoc.ErrorCheck">
            <summary>Checked error condition, possible error sources.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.Unspecified">
            <summary>Unspecified, just throw.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.InvalidCondition">
            <summary>Predicate evaluated to false.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNull">
            <summary>Checked object is null.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNotOfType">
            <summary>Checked object is of unexpected type.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.TypeIsNotOfType">
            <summary>Checked type is not assignable to expected type</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.OperationThrows">
            <summary>Invoked operation throws, it is source of inner exception.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.CollectedExceptions">
            <summary>Just stores many collected exceptions.</summary>
        </member>
        <member name="T:DryIoc.Throw">
            <summary>Enables more clean error message formatting and a bit of code contracts.</summary>
        </member>
        <member name="M:DryIoc.Throw.GetDefaultMessage(DryIoc.ErrorCheck)">
            <summary>Returns the default message specified for <see cref="T:DryIoc.ErrorCheck"/> code.</summary>
        </member>
        <member name="T:DryIoc.Throw.GetMatchedExceptionHandler">
            <summary>Declares mapping between <see cref="T:DryIoc.ErrorCheck"/> type and <paramref name="error"/> code to specific <see cref="T:System.Exception"/>.</summary>
        </member>
        <member name="F:DryIoc.Throw.GetMatchedException">
            <summary>Returns matched exception for error check and error code.</summary>
        </member>
        <member name="M:DryIoc.Throw.If(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception with provided error code if throw condition is true.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIf``1(``0,System.Boolean,System.Int32,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception with provided error code if throw condition is true.
            Otherwise returns source <paramref name="arg0"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNull``1(``0,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg"/> is null, otherwise returns <paramref name="arg"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotInstanceOf``1(``0,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg0"/> is not assignable to type specified by <paramref name="arg1"/>,
            otherwise just returns <paramref name="arg0"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotImplementedBy(System.Type,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws if <paramref name="arg0"/> is not assignable from <paramref name="arg1"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.IfThrows``2(System.Func{``1},System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Invokes <paramref name="operation"/> and in case of <typeparamref name="TEx"/> re-throws it as inner-exception.</summary>
        </member>
        <member name="M:DryIoc.Throw.It(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
        </member>
        <member name="M:DryIoc.Throw.WithDetails(System.Object,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws <paramref name="error"/> instead of returning value of <typeparamref name="T"/>.
            Supposed to be used in expression that require some return value.</summary>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws if contidion is true, otherwise returns the `default(T)` value</summary>
        </member>
        <member name="M:DryIoc.Throw.When(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws if contidion is true, otherwise returns the `default(T)` value</summary>
        </member>
        <member name="M:DryIoc.Throw.Many(System.Int32,DryIoc.ContainerException[])">
            <summary>Throws the one with manyh collected exceptions</summary>
        </member>
        <member name="M:DryIoc.Throw.ScopeIsDisposed(DryIoc.IScope,DryIoc.IResolverContext)">
            <summary>Throws the exception with info about the disposed scope and 
            the dispose stack trace if it is supported by resolver context.</summary>
        </member>
        <member name="M:DryIoc.Throw.StateIsRequiredToUseItem(System.Object,System.Type)">
            <summary>Print the d*mn exception</summary>
        </member>
        <member name="T:DryIoc.ThrowInGeneratedCode">
            <summary>Called from the generated code to check if WeakReference.Value is GCed.</summary>
        </member>
        <member name="M:DryIoc.ThrowInGeneratedCode.WeakRefReuseWrapperGCed(System.Object)">
            <summary>Throws if the object is null.</summary>
        </member>
        <member name="T:DryIoc.ReflectionTools">
            <summary>Contains helper methods to work with Type: for instance to find Type implemented base types and interfaces, etc.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.TryRethrowWithPreservedStackTrace(System.Exception)">
            <summary>Preserves the stack trace before re-throwing.</summary>
        </member>
        <member name="T:DryIoc.ReflectionTools.AsImplementedType">
            <summary>Flags for <see cref="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)"/> method.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.None">
            <summary>Include nor object not source type.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.SourceType">
            <summary>Include source type to list of implemented types.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.ObjectType">
            <summary>Include <see cref="T:System.Object"/> type to list of implemented types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)">
            <summary>Returns all interfaces and all base types (in that order) implemented by <paramref name="sourceType"/>.
            Specify <paramref name="asImplementedType"/> to include <paramref name="sourceType"/> itself as first item and
            <see cref="T:System.Object"/> type as the last item.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllMembers(System.Type,System.Boolean)">
            <summary>Gets all declared and if specified, the base members too.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.ContainsAllGenericTypeParameters(System.Type,System.Type[])">
            <summary>Returns true if the <paramref name="openGenericType"/> contains all generic parameters
            from <paramref name="genericParameters"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.TryCloseGenericTypeOrMethod``1(``0,System.Type[],System.Func{``0,System.Type[],``0},System.Boolean,System.Int32,DryIoc.Request)">
            <summary>Where the `T` should be either Type or MethodInfo</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsCompilerGenerated(System.Type)">
            <summary>Returns true if class is compiler generated. Checking for CompilerGeneratedAttribute
            is not enough, because this attribute is not applied for classes generated from "async/await".</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosedGeneric(System.Type)">
            <summary>Returns true if type is closed generic: does not have open generic parameters, only closed/concrete ones.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsOpenGeneric(System.Type)">
            <summary>Returns true if type if open generic: contains at list one open generic parameter. Could be generic type definition as well.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericDefinitionOrNull(System.Type)">
            <summary>Returns generic type definition if type is generic and null otherwise.</summary>
            [MethodImpl((MethodImplOptions)256)]
        </member>
        <member name="M:DryIoc.ReflectionTools.GetArrayElementTypeOrNull(System.Type)">
            <summary>If type is array returns is element type, otherwise returns null.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPublicOrNestedPublic(System.Type)">
            <summary>Checks if type is public or nested public in public type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Type)">
            <summary>Returns true if type is static.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.HasConversionOperatorTo(System.Type,System.Type)">
            <summary>Returns true if type can be casted with conversion operators.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConversionOperatorOrNull(System.Type,System.Type)">
            <summary>Finds the conversion operator or returns null</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSourceConversionOperatorToTarget(System.Type,System.Type)">
            Returns `target source.op_(Explicit|Implicit)(source)` or null if not found
        </member>
        <member name="M:DryIoc.ReflectionTools.GetTargetConversionOperatorFromSource(System.Type,System.Type)">
            Returns `target target.op_(Explicit|Implicit)(source)` or null if not found
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo(System.Type,System.Type)">
            <summary>Returns true if type is assignable to <paramref name="other"/> type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo``1(System.Type)">
            <summary>Returns true if type is assignable to <typeparamref name="T"/> type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableVariantGenericTypeFrom(System.Type,System.Type)">
            <summary>`to` should be the closed-generic type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsTypeOf(System.Type,System.Object)">
            <summary>Returns true if type of <paramref name="obj"/> is assignable to source <paramref name="type"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPrimitive(System.Type,System.Boolean)">
            <summary>Returns true if provided type IsPrimitive in .Net terms, or enum, or string,
            or array of primitives if <paramref name="orArrayOfPrimitives"/> is true.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Type,System.Type,System.Boolean)">
            <summary>Returns all attributes defined on <paramref name="type"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMembers``1(System.Type,System.Func{System.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Recursive method to enumerate all input type and its base types for specific details.
            Details are returned by <paramref name="getMembers"/> delegate.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.PublicConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.PublicAndInternalConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Constructors(System.Type,System.Boolean,System.Boolean)">
            <summary>Enumerates all constructors from input type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Boolean,System.Type[])">
            <summary>Searches and returns the first constructor by its signature, e.g. with the same number of parameters of the same type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Type[])">
            <summary>Searches and returns constructor by its signature.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Constructor(System.Type,System.Type[])">
            <summary>Searches and returns constructor by its signature, or throws if not found</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleConstructorOrNull(System.Type,System.Boolean)">
            <summary>Returns single constructor otherwise (if no constructor or more than one) returns null.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.SingleConstructor(System.Type,System.Boolean)">
            <summary>Returns single constructor otherwise (if no or more than one) throws an exception</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleMethodOrNull(System.Type,System.String,System.Boolean)">
            <summary>Looks up for single declared method with the specified name. Returns null if method is not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.SingleMethod(System.Type,System.String,System.Boolean)">
            <summary>Looks for single declared (not inherited) method by name, and throws if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Method(System.Type,System.String,System.Type[])">
            <summary>Looks up for method with and specified parameter types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMethodOrNull(System.Type,System.String,System.Type[])">
            <summary>Looks up for method with and specified parameter types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Property(System.Type,System.String,System.Boolean)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPropertyOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Field(System.Type,System.String,System.Boolean)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetFieldOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAssembly(System.Type)">
            <summary>Returns type assembly.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsExplicitlyImplemented(System.Reflection.PropertyInfo)">
            <summary>Is <c>true</c> for interface declared property explicitly implemented, e.g. <c>IInterface.Prop</c></summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.MemberInfo)">
            <summary>Returns true if member is static, otherwise returns false.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.PropertyInfo,System.Boolean)">
            Find if property is static
        </member>
        <member name="M:DryIoc.ReflectionTools.GetReturnTypeOrDefault(System.Reflection.MemberInfo)">
            <summary>Return either <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>, or <see cref="P:System.Reflection.FieldInfo.FieldType"/>, 
            <see cref="P:System.Reflection.MethodInfo.ReturnType"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsBackingField(System.Reflection.FieldInfo)">
            <summary>Returns true if field is backing field for property.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>Returns true if property is indexer: aka this[].</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosureType(System.Type)">
            <summary>Returns true if type is generated type of hoisted closure.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for the member/method.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for parameter.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetLoadedTypes(System.Reflection.Assembly)">
            <summary>Get types from assembly that are loaded successfully.
            Hacks the <see cref="T:System.Reflection.ReflectionTypeLoadException"/>to get failing to load types metadata.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDefaultValueExpression(System.Type)">
            <summary>Creates default(T) expression for provided <paramref name="type"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetValueOrDefault(DryIoc.ImTools.ImHashMap{System.Type,System.Object},System.Type)">
            <summary>Optimized version of the map GetValueOrDefault for the Type key and object value</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.AddOrUpdate(DryIoc.ImTools.ImHashMap{System.Type,System.Object},System.Type,System.Object)">
            <summary>Optimized version of the map AddOrUpdate for the Type key and object value</summary>
        </member>
        <member name="T:DryIoc.PrintTools">
            <summary>Provides pretty printing/debug view for number of types.</summary>
        </member>
        <member name="F:DryIoc.PrintTools.DefaultItemSeparator">
            <summary>Default separator used for printing enumerable.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Object,System.String,System.String,System.Func{System.Type,System.String})">
            <summary>Prints input object by using corresponding Print methods for know types.</summary>
            <param name="s">Builder to append output to.</param> <param name="x">Object to print.</param>
            <param name="quote">(optional) Quote to use for quoting string object.</param>
            <param name="itemSeparator">(optional) Separator for enumerable.</param>
            <param name="getTypeName">(optional) Custom type printing policy.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends string to string builder quoting with <paramref name="quote"/> if provided.</summary>
            <param name="s">String builder to append string to.</param> <param name="str">String to print.</param>
            <param name="quote">(optional) Quote to add before and after string.</param>
            <returns>String builder with appended string.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Collections.IEnumerable,System.String,System.Action{System.Text.StringBuilder,System.Object})">
            <summary>Prints enumerable by using corresponding Print method for known item type.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="items">Items to print.</param>
            <param name="separator">(optional) Custom separator if provided.</param>
            <param name="printItem">(optional) Custom item printer if provided.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="F:DryIoc.PrintTools.GetTypeNameDefault">
            <summary>Default delegate to print Type details: by default prints Type FullName and
            skips namespace if it start with "System."</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Type,System.Func{System.Type,System.String})">
            <summary>Pretty prints the <paramref name="type"/> in proper C# representation.
            <paramref name="getTypeName"/>Allows to specify if you want Name instead of FullName.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Type,System.Func{System.Type,System.String})">
            <summary>Pretty-prints the type</summary>
        </member>
        <member name="T:DryIoc.Portable">
            <summary>Ports some methods from .Net 4.0/4.5</summary>
        </member>
        <member name="M:DryIoc.Portable.GetAssemblyTypes(System.Reflection.Assembly)">
            <summary>Portable version of Assembly.GetTypes or Assembly.DefinedTypes.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetGetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetGetMethod.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetSetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetSetMethod.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetCurrentManagedThreadID">
            <summary>Returns managed Thread ID either from Environment or Thread.CurrentThread whichever is available.</summary>
        </member>
        <member name="T:DryIoc.AsyncExecutionFlowScopeContext">
            <summary>Stores scopes propagating through async-await boundaries.</summary>
        </member>
        <member name="F:DryIoc.AsyncExecutionFlowScopeContext.ScopeContextName">
            <summary>Statically known name of root scope in this context.</summary>
        </member>
        <member name="F:DryIoc.AsyncExecutionFlowScopeContext.Default">
            It is fine to use a default instance, cause the async local scope are actually a static one
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and  should return new current scope.</summary>
            <param name="changeCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="changeCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. It is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.Dispose">
            <summary>Nothing to dispose.</summary>
        </member>
        <member name="T:DryIoc.Messages.IMessage`1">
            Base type for messages
        </member>
        <member name="T:DryIoc.Messages.EmptyResponse">
            Type for an empty response
        </member>
        <member name="F:DryIoc.Messages.EmptyResponse.Value">
            Single value of empty response
        </member>
        <member name="F:DryIoc.Messages.EmptyResponse.Task">
            Single completed task for the empty response
        </member>
        <member name="T:DryIoc.Messages.MessageExtensions">
            Message extensions
        </member>
        <member name="M:DryIoc.Messages.MessageExtensions.ToEmptyResponse(System.Threading.Tasks.Task)">
            Converts the task to empty response task
        </member>
        <member name="T:DryIoc.Messages.IMessage">
            Message with empty response
        </member>
        <member name="T:DryIoc.Messages.IMessageHandler`2">
            Base message handler
        </member>
        <member name="M:DryIoc.Messages.IMessageHandler`2.Handle(`0,System.Threading.CancellationToken)">
            Generic handler
        </member>
        <member name="T:DryIoc.Messages.IMessageHandler`1">
            Base message handler for message with empty response
        </member>
        <member name="T:DryIoc.Messages.IMessageMiddleware`2">
            Message handler middleware to handle the message and pass the result to the next middleware
        </member>
        <member name="P:DryIoc.Messages.IMessageMiddleware`2.RelativeOrder">
            <summary>`0` means the default registration order,
            lesser numbers incuding the `-1`, `-2` mean execute as a first,
            bigger numbers mean execute as a last</summary>
        </member>
        <member name="M:DryIoc.Messages.IMessageMiddleware`2.Handle(`0,System.Threading.CancellationToken,System.Func{System.Threading.Tasks.Task{`1}})">
            <summary>Handles message and passes to the next middleware</summary>
        </member>
        <member name="T:DryIoc.Messages.AsyncMessageHandler`2">
            Base class for implementing async handlers
        </member>
        <member name="M:DryIoc.Messages.AsyncMessageHandler`2.Handle(`0,System.Threading.CancellationToken)">
            Base method to implement in your inheritor
        </member>
        <member name="T:DryIoc.Messages.MiddlewareMessageHandler`2">
            Sequential middleware type of message handler decorator
        </member>
        <member name="M:DryIoc.Messages.MiddlewareMessageHandler`2.#ctor(DryIoc.Messages.IMessageHandler{`0,`1},System.Collections.Generic.IEnumerable{DryIoc.Messages.IMessageMiddleware{`0,`1}})">
            Decorates message handler with optional middlewares
        </member>
        <member name="M:DryIoc.Messages.MiddlewareMessageHandler`2.Handle(`0,System.Threading.CancellationToken)">
            Composes middlewares with handler
        </member>
        <member name="T:DryIoc.Messages.BroadcastMessageHandler`1">
            Broadcasting type of message handler decorator
        </member>
        <member name="M:DryIoc.Messages.BroadcastMessageHandler`1.#ctor(System.Collections.Generic.IEnumerable{DryIoc.Messages.IMessageHandler{`0,DryIoc.Messages.EmptyResponse}})">
            Constructs the hub with the handler and optional middlewares
        </member>
        <member name="M:DryIoc.Messages.BroadcastMessageHandler`1.Handle(`0,System.Threading.CancellationToken)">
            Composes middlewares with handler
        </member>
        <member name="T:DryIoc.Messages.MessageMediator">
            <summary>The central mediator entry-point</summary>
        </member>
        <member name="M:DryIoc.Messages.MessageMediator.#ctor(DryIoc.IResolver)">
            <summary>Constructs the mediator</summary>
        </member>
        <member name="M:DryIoc.Messages.MessageMediator.Send``2(``0,System.Threading.CancellationToken)">
            <summary>Sends the message with response to the resolved Single handler</summary>
        </member>
        <member name="M:DryIoc.Messages.MessageMediator.Send``1(``0,System.Threading.CancellationToken)">
            <summary>Sends the message with empty response to resolved Single handler</summary>
        </member>
        <member name="T:DryIoc.ITest">
            <summary>Common abstraction to run the tests</summary>
        </member>
        <member name="M:DryIoc.ITest.Run">
            <summary>Runs the tests and should return the number of running tests</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.Expression">
            <summary>The base class and the Factpry methods provider for the Expression.</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.Expression.NodeType">
            <summary>Expression node type.</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.Expression.Type">
            <summary>All expressions should have a Type.</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.Expression.Tag">
            <summary>You may use it whatever you like overloading for the specific value in your custom expression.</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.Expression.IsIntrinsic">
            <summary>Allows to overwrite the FEC stages to customize and optimize 
            the expression constant(label, blocks, tries) collection and il emitting phase</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.TryCollectBoundConstants(DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags,DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo@,DryIoc.FastExpressionCompiler.LightExpression.IParameterProvider,System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo@)">
            <summary>The first FEC stage of expression traversal where closure information is collected including the 
            constant and the nested lambdas. Beside that the labels, block and try-catch information is also collected
            for the next IL-emitting stage. The information regarding the currently traversed lambda expression
            is accumulated in the `closure` structure. The `rootClosure` hold the first lambda expression info
            for any nested lambda expression, which is indicated by `isNestedLambda`.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.TryEmit(DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags,DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo@,DryIoc.FastExpressionCompiler.LightExpression.IParameterProvider,System.Reflection.Emit.ILGenerator,DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags,System.Int32)">
            <summary>The second FEC state to emit the actual IL op-codes based on the information collected by the first traversal
            and available in the `closure` structure. Find the expression examples below by searching `IsIntrinsic => true`.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ToExpression">
            <summary>Converts the LightExpression to the System Expression to enable fallback to the System Compile</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ToString">
            <summary>Converts to Expression and outputs its as string</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Reduce">
            <summary>Reduces the Expression to simple ones</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Variable(System.Type,System.String)">
            <summary>Variable is not by-ref yet</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Constant(System.Boolean)">
            <summary>Avoids the boxing for all (two) bool values</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Not(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents a bitwise complement operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.TypeAs(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type)">
            <summary>Creates a UnaryExpression that represents an explicit reference or boxing conversion where null is supplied if the conversion fails.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ArrayLength(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents an expression for obtaining the length of a one-dimensional array.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Convert(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type)">
            <summary>Creates a UnaryExpression that represents a type conversion operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Convert(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type,System.Reflection.MethodInfo)">
            <summary>Creates a UnaryExpression that represents a conversion operation for which the implementing method is specified.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ConvertChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type)">
            <summary>Creates a UnaryExpression that represents a conversion operation that throws an exception if the target type is overflowed.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ConvertChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type,System.Reflection.MethodInfo)">
            <summary>Creates a UnaryExpression that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Decrement(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents the decrementing of the expression by 1.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Increment(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents the incrementing of the expression value by 1.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.IsFalse(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Returns whether the expression evaluates to false.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.IsTrue(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Returns whether the expression evaluates to true.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type)">
            <summary>Creates a UnaryExpression, given an operand, by calling the appropriate factory method.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Negate(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents an arithmetic negation operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.NegateChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents an arithmetic negation operation that has overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.OnesComplement(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Returns the expression representing the ones complement.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.PreIncrementAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that increments the expression by 1 and assigns the result back to the expression.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.PostIncrementAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.PreDecrementAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that decrements the expression by 1 and assigns the result back to the expression.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.PostDecrementAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Quote(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents an expression that has a constant value of type Expression.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.UnaryPlus(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents a unary plus operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Unbox(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type)">
            <summary>Creates a UnaryExpression that represents an explicit unboxing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Lambda``1(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.String,DryIoc.FastExpressionCompiler.LightExpression.ParameterExpression[])">
            <summary><paramref name="name"/> is ignored for now, the method is just for compatibility with SysExpression</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ArrayIndex(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents applying an array index operator to an array of rank one.</summary>
            <param name="array">A Expression to set the Left property equal to.</param>
            <param name="index">A Expression to set the Right property equal to.</param>
            <returns>A BinaryExpression that has the NodeType property equal to ArrayIndex and the Left and Right properties set to the specified values.</returns>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.MemberInit(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.MemberBinding[])">
            <summary>Does not present in System Expression. Enables member assignment on existing instance expression.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Assign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an assignment operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.PowerAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents raising an expression to a power and assigning the result back to the expression.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.AddAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an addition assignment operation that does not have overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.AddAssignChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an addition assignment operation that has overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.AndAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise AND assignment operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.OrAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise OR assignment operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ExclusiveOrAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise XOR assignment operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.RightShiftAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise right-shift assignment operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ModuloAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a remainder assignment operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.SubtractAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a subtraction assignment operation that does not have overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.SubtractAssignChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a subtraction assignment operation that has overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.MultiplyAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a multiplication assignment operation that does not have overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.MultiplyAssignChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a multiplication assignment operation that has overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.DivideAssign(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a division assignment operation that does not have overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Add(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic addition operation that does not have overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.AddChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic addition operation that has overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ExclusiveOr(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise XOR operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.LeftShift(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise left-shift operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Modulo(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic remainder operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.RightShift(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise right-shift operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Subtract(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic subtraction operation that does not have overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.SubtractChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic subtraction operation that has overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Multiply(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic multiplication operation that does not have overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.MultiplyChecked(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic multiplication operation that has overflow checking.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Divide(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an arithmetic division operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Power(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents raising a number to a power.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.And(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise AND operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.AndAlso(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a conditional AND operation that evaluates the second operand only if the first operand evaluates to true.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Or(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a bitwise OR operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.OrElse(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a conditional OR operation that evaluates the second operand only if the first operand evaluates to false.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Equal(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an equality comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.NotEqual(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents an inequality comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.GreaterThan(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a "greater than" numeric comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.GreaterThanOrEqual(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a "greater than or equal" numeric comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.LessThan(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a "less than" numeric comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.LessThanOrEqual(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a " less than or equal" numeric comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Loop(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.LabelTarget)">
            <summary>Creates a LoopExpression with the given body and (optional) break target.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Loop(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.LabelTarget,DryIoc.FastExpressionCompiler.LightExpression.LabelTarget)">
            <summary>Creates a LoopExpression with the given body.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Throw(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a UnaryExpression that represents a throwing of an exception.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Throw(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type)">
            <summary>Creates a UnaryExpression that represents a throwing of an exception with a given type.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression)">
            <summary>Creates a <see cref="T:DryIoc.FastExpressionCompiler.LightExpression.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ReferenceEqual(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a reference equality comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.ReferenceNotEqual(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a reference inequality comparison.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Coalesce(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates a BinaryExpression that represents a coalescing operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Coalesce(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Type)">
            <summary>Creates a BinaryExpression that represents a coalescing operation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.Expression.Coalesce(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression)">
            <summary>Creates a BinaryExpression that represents a coalescing operation, given a conversion function.</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.BinaryExpression.IsLiftedToNull">
            <summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ConstantExpression">
            <summary>The base constant type</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ConstantExpression.ToString">
            <summary>I want to see the actual Value not the default one</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.NewExpression.NoByRefArgs">
            <summary>Ensures that there is no by-ref (in, our, ref) parameters in the constructor.
            Which allows some optimizations when compiling the expression to the delegate</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.IndexExpression">
            <summary>For indexer property or array access.</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.BlockExpression">
            <summary>Base Block expression with no variables and with Type of its last (Result) exporession</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.TypedBlockExpression">
            <summary>Block with no variable but user-specified type.</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.DebugInfoExpression">
             <summary>
             Emits or clears a sequence point for debug information.
            
             This allows the debugger to highlight the correct source code when
             debugging.
             </summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags">
            <summary>The options for the compiler</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags.Default">
            <summary>The default options: Invocation lambda is inlined, no debug info</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags.NoInvocationLambdaInlining">
            <summary>Prevents the inlining of the lambda in the Invocation expression to optimize for the multiple same lambda compiled once</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags.EnableDelegateDebugInfo">
            <summary>Adds the Expression, ExpressionString, and CSharpString to the delegate closure for the debugging inspection</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags.ThrowOnNotSupportedExpression">
            <summary>When the flag set then instead of the returning `null` the specific exception</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.NotSupported">
            <summary>Indicates the not supported expression combination</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.NewArrayInit_MultidimensionalArray">
            <summary>Multi-dimensional array initializer is not supported</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.Quote">
            <summary>Quote is not supported</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.Dynamic">
            <summary>Dynamic is not supported</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.RuntimeVariables">
            <summary>RuntimeVariables is not supported</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.MemberInit_MemberBinding">
            <summary>MemberInit MemberBinding is not supported</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.MemberInit_ListBinding">
            <summary>MemberInit ListBinding is not supported</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.Try_GotoReturnToTheFollowupLabel">
            <summary>Goto of the Return kind from the TryCatch is not supported</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.Assign_Target">
            <summary>Not supported assignment target</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupported.TypeEqual">
            <summary> ExpressionType.TypeEqual is not supported </summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.NotSupportedExpressionException">
            <summary>FEC Not Supported exception</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.NotSupportedExpressionException.Reason">
            <summary>The reason</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.NotSupportedExpressionException.#ctor(DryIoc.FastExpressionCompiler.LightExpression.NotSupported)">
            <summary>Constructor</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.NotSupportedExpressionException.#ctor(DryIoc.FastExpressionCompiler.LightExpression.NotSupported,System.String)">
            <summary>Constructor</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.IDelegateDebugInfo">
            <summary>The interface is implemented by the compiled delegate Target if `CompilerFlags.EnableDelegateDebugInfo` is set.</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.IDelegateDebugInfo.Expression">
            <summary>The lambda expression object that was compiled to the delegate</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.IDelegateDebugInfo.ExpressionString">
            <summary>The lambda expression construction syntax C# code</summary>
        </member>
        <member name="P:DryIoc.FastExpressionCompiler.LightExpression.IDelegateDebugInfo.CSharpString">
            <summary>The lambda expression equivalent C# code</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler">
            <summary>Compiles expression to delegate ~20 times faster than Expression.Compile.
            Partial to extend with your things when used as source file.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression,System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFastToIL(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression,System.Reflection.Emit.ILGenerator,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles a static method to the passed IL Generator.
            Could be used as alternative for `CompileToMethod` like this <code><![CDATA[funcExpr.CompileFastToIL(methodBuilder.GetILGenerator())]]></code>.
            Check `IssueTests.Issue179_Add_something_like_LambdaExpression_CompileToMethod.cs` for example.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression,System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileSys``1(DryIoc.FastExpressionCompiler.LightExpression.Expression{``0})">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileSys(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression)">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(DryIoc.FastExpressionCompiler.LightExpression.Expression{``0},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Func{``0}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``2(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``3(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``4(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``5(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3,``4}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``6(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``7(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Action},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Action{``0}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``2(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``3(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``4(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2,``3}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``5(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2,``3,``4}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``6(DryIoc.FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2,``3,``4,``5}},System.Boolean,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompile``1(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/></summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression,DryIoc.FastExpressionCompiler.LightExpression.ConstantExpression[])">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of) -
            Constant expression should be the in order of Fields in closure object!
            Note 1: Use it on your own risk - FEC won't verify the expression is compile-able with passed closure, it is up to you!
            Note 2: The expression with NESTED LAMBDA IS NOT SUPPORTED!
            Note 3: `Label` and `GoTo` are not supported in this case, because they need first round to collect out-of-order labels</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression,DryIoc.FastExpressionCompiler.LightExpression.ConstantExpression[],DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of)</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompileWithoutClosure``1(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags)">
            <summary>Tries to compile expression to "static" delegate, skipping the step of collecting the closure object.</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo">
            Track the info required to build a closure object + some context information not directly related to closure.
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.LastEmitIsAddress">
            <summary>Tracks that the last emit was an address</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo._blockStack">
            Tracks the stack of blocks where are we in emit phase
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.Labels">
            Map of the links between Labels and Goto's
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.Constants">
            Constant expressions to find an index (by reference) of constant expression from compiled expression.
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.ConstantUsageThenVarIndex">
            Constant usage count and variable index.
            It is a separate collection from the Constants because we directly convert later into the closure array
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.NonPassedParameters">
            Parameters not passed through lambda parameter list But used inside lambda body.
            The top expression should Not contain not passed parameters. 
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.NestedLambdaOrLambdas">
            All nested lambda(s) `NestedLambdaInfo|NestedLambdaInfo[]` recursively nested in expression
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.#ctor(DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureStatus,System.Object[],System.Int16[])">
            <summary>Populates info directly with provided closure object and constants.
            If provided, the <paramref name="constUsage"/> is the const variable indexes,
            should be the size of <paramref name="constValues"/>
            </summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.PushBlockWithVars(DryIoc.FastExpressionCompiler.LightExpression.ParameterExpression)">
            LocalVar maybe a `null` in a collecting phase when we only need to decide if ParameterExpression is an actual parameter or variable
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo.PushBlockWithVars(System.Collections.Generic.IReadOnlyList{DryIoc.FastExpressionCompiler.LightExpression.ParameterExpression},System.Int32[])">
            LocalVars maybe a `null` in collecting phase when we only need to decide if ParameterExpression is an actual parameter or variable
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaInfo">
            <summary>Collects the lambda info for the compilation</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaInfo.LambdaExpression">
            <summary>The lambda expression</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaInfo.ClosureInfo">
            <summary>The lambda expression closure info</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaInfo.Lambda">
            <summary>Compiled lambda</summary>
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaInfo.LambdaVarIndex">
            <summary>Index of the compiled lambda in the parent lambda closure array</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.NestedLambdaInfo.#ctor(DryIoc.FastExpressionCompiler.LightExpression.LambdaExpression)">
            <summary>Constructor</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.IsClosureBoundConstant(System.Object,System.Type)">
            Helps to identify constants as the one to be put into the Closure
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags">
            The minimal context-aware flags set by parent
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.Empty">
            Default is no flags
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.IgnoreResult">
            The result of expression is ignored and maybe popped out
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.Call">
            Some parent is the call expression
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.MemberAccess">
            Any Parent Expression is a MemberExpression
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.Arithmetic">
            Some arithmetic operation
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.Coalesce">
            Subject
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.InstanceAccess">
            Expression with instance object (method call or member access or array access)
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.DupMemberOwner">
            Subject
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.TryCatch">
            Subject
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.InstanceCall">
            Combination`of InstanceAccess and Call
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.CtorCall">
            Constructor call
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.IndexAccess">
            Indexer
        </member>
        <member name="F:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags.InlinedLambdaInvoke">
            Invoking the inlined lambda (the default System.Expression behavior)
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.EmittingVisitor.TryEmit(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.IParameterProvider,System.Reflection.Emit.ILGenerator,DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo@,DryIoc.FastExpressionCompiler.LightExpression.CompilerFlags,DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags,System.Int32)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ExpressionCompiler.EmittingVisitor.EmitLoadConstantInt(System.Reflection.Emit.ILGenerator,System.Int32)">
            Efficiently emit the int constant
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ILGeneratorHacks">
            <summary>Reflecting the internal methods to access the more performant for defining the local variable</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ILGeneratorHacks.GetNextLocalVarIndex(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>Efficiently returns the next variable index, hopefully without unnecessary allocations.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ToExpressionPrinter.ToExpressionString(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.TryPrintConstant)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            </summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ToExpressionPrinter.ToExpressionString(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Collections.Generic.List{DryIoc.FastExpressionCompiler.LightExpression.ParameterExpression}@,System.Collections.Generic.List{DryIoc.FastExpressionCompiler.LightExpression.Expression}@,System.Collections.Generic.List{DryIoc.FastExpressionCompiler.LightExpression.LabelTarget}@,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,DryIoc.FastExpressionCompiler.LightExpression.TryPrintConstant)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            In addition, returns the gathered expressions, parameters ad labels. 
            </summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.TryPrintConstant">
            <summary>Output the constant to C# string or should return `null`</summary>
        </member>
        <member name="T:DryIoc.FastExpressionCompiler.LightExpression.ToCSharpPrinter">
            <summary>Converts the expression into the valid C# code representation</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ToCSharpPrinter.ToCSharpString(DryIoc.FastExpressionCompiler.LightExpression.Expression)">
            <summary>Tries hard to convert the expression into the correct C# code</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ToCSharpPrinter.ToCSharpString(DryIoc.FastExpressionCompiler.LightExpression.Expression,DryIoc.FastExpressionCompiler.LightExpression.TryPrintConstant)">
            <summary>Tries hard to convert the expression into the correct C# code</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.ToCSharpPrinter.ToCSharpString(DryIoc.FastExpressionCompiler.LightExpression.Expression,System.Text.StringBuilder,System.Int32,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,DryIoc.FastExpressionCompiler.LightExpression.TryPrintConstant)">
            <summary>Tries hard to convert the expression into the correct C# code</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.ToCode(System.Type,System.Boolean,System.Func{System.Type,System.String,System.String},System.Boolean)">
            <summary>Converts the <paramref name="type"/> into the proper C# representation.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.ToCode(System.Boolean)">
            <summary>Prints valid C# Boolean</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.ToCode(System.String)">
            <summary>Prints valid C# String escaping the things</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.ToEnumValueCode(System.Type,System.Object,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints valid C# Enum literal</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.ToCommaSeparatedCode(System.Collections.IEnumerable,DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as the array initializer.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.ToArrayInitializerCode(System.Collections.IEnumerable,System.Type,DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as array initializer.</summary>
        </member>
        <member name="M:DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.ToCode(System.Object,DryIoc.FastExpressionCompiler.LightExpression.CodePrinter.IObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>
            Prints a valid C# for known <paramref name="x"/>,
            otherwise uses passed <paramref name="notRecognizedToCode"/> or falls back to `ToString()`.
            </summary>
        </member>
        <member name="T:DryIoc.ImTools.Fun">
            <summary>Helpers for functional composition</summary>
        </member>
        <member name="M:DryIoc.ImTools.Fun.Always``1(``0)">
            <summary>
            Always a true condition.
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.Id``1(``0)">
            <summary>
            Identity function returning passed argument as result.
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.To``2(``0,System.Func{``0,``1})">
            <summary>
            Forward pipe operator (`|>` in F#)
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.To``3(``0,``1,System.Func{``0,``1,``2})">
            <summary>
            Forward pipe operator (`|>` in F#) with the additional state A for two arguments function
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.To``1(System.Object)">
            <summary>
            Cast to the R type with the forward pipe operator (`|>` in F#)
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.Do``1(``0,System.Action{``0})">
            <summary>
            Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.Do``2(``0,``1,System.Action{``0,``1})">
            <summary>
            Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value and the state object
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.ToFunc``2(``1,``0)">
            <summary>
            Lifts argument to Func without allocations ignoring the first argument.
            For example if you have `Func{T, R} = _ => instance`,
            you may rewrite it without allocations as `instance.ToFunc{A, R}`
            </summary> 
        </member>
        <member name="M:DryIoc.ImTools.Fun.Swap``1(``0@,``0@)">
            <summary>Performant swapper</summary>
        </member>
        <member name="T:DryIoc.ImTools.Lazy">
            <summary>Helpers for lazy instantiations</summary>
        </member>
        <member name="M:DryIoc.ImTools.Lazy.Of``1(System.Func{``0})">
            <summary>Provides result type inference for creation of lazy.</summary>
        </member>
        <member name="T:DryIoc.ImTools.St`1">
            <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state</summary>
        </member>
        <member name="F:DryIoc.ImTools.St`1.a">
            <summary>A</summary>
        </member>
        <member name="M:DryIoc.ImTools.St`1.Pool">
            <summary>Puts the pooled instance back replacing the old one</summary>
        </member>
        <member name="M:DryIoc.ImTools.St`1.Reset">
            <summary>Puts the pooled instance back replacing the old one</summary>
        </member>
        <member name="M:DryIoc.ImTools.St`1.ResetButGetA">
            <summary>Puts the pooled instance back replacing the old one</summary>
        </member>
        <member name="T:DryIoc.ImTools.St`2">
            <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state</summary>
        </member>
        <member name="F:DryIoc.ImTools.St`2.a">
            <summary>A</summary>
        </member>
        <member name="F:DryIoc.ImTools.St`2.b">
            <summary>B</summary>
        </member>
        <member name="M:DryIoc.ImTools.St`2.Pool">
            <summary>Puts the pooled instance back replacing the old one</summary>
        </member>
        <member name="M:DryIoc.ImTools.St`2.Reset">
            <summary>Puts the pooled instance back replacing the old one</summary>
        </member>
        <member name="M:DryIoc.ImTools.St`2.ResetButGetA">
            <summary>Puts the pooled instance back replacing the old one</summary>
        </member>
        <member name="M:DryIoc.ImTools.St`2.ResetButGetB">
            <summary>Puts the pooled instance back replacing the old one</summary>
        </member>
        <member name="T:DryIoc.ImTools.St">
            <summary>State factory and helper methods</summary>
        </member>
        <member name="M:DryIoc.ImTools.St.Of``1(``0)">
            <summary>Creates the state out of the passed arguments</summary>
        </member>
        <member name="M:DryIoc.ImTools.St.Rent``1(``0)">
            <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments</summary>
        </member>
        <member name="M:DryIoc.ImTools.St.Of``2(``0,``1)">
            <summary>Creates the state out of the passed arguments</summary>
        </member>
        <member name="M:DryIoc.ImTools.St.Rent``2(``0,``1)">
            <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments</summary>
        </member>
        <member name="T:DryIoc.ImTools.ArrayTools">
            <summary>Methods to work with immutable arrays and some sugar.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Empty``1">
            <summary>Returns singleton empty array of provided type.</summary> 
            <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.One``1(``0)">
            <summary>Wraps item in array.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.EmptyIfNull``1(``0[])">
            <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.ToArrayOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.ToListOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Copy``1(``0[])">
            <summary>Array copy</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.CopyNonEmpty``1(``0[])">
            <summary>Fast array copy without checking the items for the null or the emptyness</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Append``1(``0[],``0[])">
            <summary>Returns the new array consisting from all items from source array then the all items from added array.
            If source is null or empty then the added array will be returned. If added is null or empty then the source will be returned.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Performant concat of enumerables in case of arrays. But performance will degrade if you use Concat().Where().</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.AppendOrUpdate``1(``0[],``0,System.Int32)">
            <summary>Returns new array with <paramref name="value"/> appended, 
            or <paramref name="value"/> at <paramref name="index"/>, if specified.
            If source array could be null or empty, then single value item array will be created despite any index.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.UpdateNonEmpty``1(``0[],``0,System.Int32)">
            <summary>Updates the item in the copy of the array. The array should be non-empty.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.AppendNonEmpty``1(``0[],``0[])">
            <summary>Returns the new array consisting from all items from source array then the all items from added array.
            Assumes that both arrays are non-empty to avoid the checks.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Append``1(``0[],``0)">
            <summary>Returns the new array consisting from all items from source array plus the value.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.AppendToNonEmpty``1(``0[],``0)">
            <summary>Returns new array with <paramref name="value"/> appended. Assumes that `source` is not empty to avoid the checks.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.PrependToNonEmpty``1(``0[],``0)">
            <summary>Returns new array with <paramref name="value"/> prepended. Assumes that `source` is not empty to avoid the checks.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.IndexOf``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
            then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.IndexOf``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            <summary>Minimizes the allocations for closure in predicate lambda with the provided <paramref name="state"/></summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.IndexOf``1(``0[],``0)">
            <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.IndexOfReference``1(``0[],``0)">
            <summary>The same as `IndexOf` but searching for the item by reference</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.RemoveAt``1(``0[],System.Int32)">
            <summary>Produces new array without item at specified <paramref name="index"/>. 
            Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Remove``1(``0[],``0)">
            <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.FindFirst``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.FindFirst``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            <summary>Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.FindFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.SingleOrDefaultIfMany``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns element if collection consist on single element, otherwise returns default value.
            It does not throw for collection with many elements</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.ForEach``1(``0[],System.Action{``0})">
            <summary>Does <paramref name="action"/> for each item</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Copy``1(``0[],System.Int32,System.Int32)">
            <summary>Copies the slice to the new array, just a sugar extension method</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.AppendTo``1(``0[],``0[],System.Int32,System.Int32)">
            <summary>Appends the slice from the source to the end of the results array possibly the resizing the results to accomodate the slice</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``2(``1[],``0,System.Func{``0,``1,System.Boolean})">
            <summary>Match with the additional state to use in <paramref name="condition"/> to minimize the allocations 
            in <paramref name="condition"/> lambda closure</summary> 
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``3(``2[],``0,``1,System.Func{``0,``1,``2,System.Boolean})">
            <summary>Match with the additional state to use in <paramref name="condition"/> to minimize the allocations 
            in <paramref name="condition"/> lambda closure</summary> 
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``2(``0[],System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``3(``1[],``0,System.Func{``0,``1,System.Boolean},System.Func{``0,``1,``2})">
            <summary>Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> 
            to minimize the allocations in <paramref name="condition"/> lambda closure </summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``4(``2[],``0,``1,System.Func{``0,``1,``2,System.Boolean},System.Func{``0,``1,``2,``3})">
            <summary>Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> 
            to minimize the allocations in <paramref name="condition"/> lambda closure </summary>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Map``2(``0[],System.Func{``0,``1})">
            <summary>Maps all items from source to result array.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Map``3(``0[],``1,System.Func{``1,``0,``2})">
            Map with additional state to use in <paramref name="map"/> to minimize allocations in <paramref name="map"/> lambda closure 
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Map``4(``0[],``1,``2,System.Func{``1,``2,``0,``3})">
            Map with additional two states to use in <paramref name="map"/> to minimize allocations in <paramref name="map"/> lambda closure 
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Maps all items from source to result collection. If possible uses fast array Map otherwise Enumerable.Select.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="M:DryIoc.ImTools.ArrayTools.Match``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array,
            otherwise just calls Where, Select</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="T:DryIoc.ImTools.Ref`1">
            <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="M:DryIoc.ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)"/>.</summary>
            <typeparam name="T">Type of object to wrap.</typeparam>
        </member>
        <member name="P:DryIoc.ImTools.Ref`1.Value">
            <summary>Gets the wrapped value.</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.#ctor(`0)">
            <summary>Creates ref to object, optionally with initial value provided.</summary>
            <param name="initialValue">(optional) Initial value.</param>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.Swap(System.Func{`0,`0})">
            <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="M:DryIoc.ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)"/> for details.</summary>
            <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.Swap``1(``0,System.Func{`0,``0,`0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.Swap``2(``0,``1,System.Func{`0,``0,``1,`0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/>, <paramref name="b"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.SwapAndGetNewValue``1(``0,System.Func{`0,``0,`0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.Swap(`0)">
            <summary>Just sets new value ignoring any intermingled changes and returns the original value</summary>
            <param name="newValue"></param> <returns>old value</returns>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.SetNonAtomic(`0)">
            <summary>Directly sets the value and returns the new value</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.TrySwapIfStillCurrent(`0,`0)">
            <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
            <param name="currentValue"></param> <param name="newValue"></param>
            <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
            <example><c>[!CDATA[
            var value = SomeRef.Value;
            if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
                SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
            ]]</c></example>
        </member>
        <member name="M:DryIoc.ImTools.Ref`1.UnsafeSet(`0)">
            <summary>Just sets the new value</summary>
        </member>
        <member name="T:DryIoc.ImTools.Ref">
            <summary>Provides optimistic-concurrency consistent <see cref="M:DryIoc.ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)"/> operation.</summary>
        </member>
        <member name="F:DryIoc.ImTools.Ref.RETRY_COUNT_UNTIL_THROW">
            The default max retry count - can be overridden by `Swap` optional parameter 
        </member>
        <member name="M:DryIoc.ImTools.Ref.Of``1(``0)">
            <summary>Factory for <see cref="T:DryIoc.ImTools.Ref`1"/> with type of value inference.</summary>
            <typeparam name="T">Type of value to wrap.</typeparam>
            <param name="value">Initial value to wrap.</param>
            <returns>New ref.</returns>
        </member>
        <member name="M:DryIoc.ImTools.Ref.NewRef``1(DryIoc.ImTools.Ref{``0})">
            <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
            <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        </member>
        <member name="M:DryIoc.ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)">
            <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
            Second, it checks that original value is not changed. 
            If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
            <typeparam name="T">Type of value to swap.</typeparam>
            <param name="value">Reference to change to new value</param>
            <param name="getNewValue">Delegate to get value from old one.</param>
            <param name="retryCountUntilThrow">(optional)</param>
            <returns>Old/original value. By analogy with <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/>.</returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:DryIoc.ImTools.Ref.Swap``2(``0@,``1,System.Func{``0,``1,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref.SwapAndGetNewValue``2(``0@,``1,System.Func{``0,``1,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref.Swap``3(``0@,``1,``2,System.Func{``0,``1,``2,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/>, <paramref name="b"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:DryIoc.ImTools.Ref.Swap``4(``0@,``1,``2,``3,System.Func{``0,``1,``2,``3,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/>, <paramref name="b"/>, <paramref name="c"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="T:DryIoc.ImTools.IPrintable">
            <summary>Printable thing via provided printer </summary>
        </member>
        <member name="M:DryIoc.ImTools.IPrintable.Print(System.Text.StringBuilder,System.Func{System.Text.StringBuilder,System.Object,System.Text.StringBuilder})">
            <summary>Print to the provided string builder via the provided printer.</summary>
        </member>
        <member name="T:DryIoc.ImTools.Hasher">
            <summary>Produces good enough hash codes for the fields</summary>
        </member>
        <member name="M:DryIoc.ImTools.Hasher.Combine``2(``0,``1)">
            <summary>Combines hashes of two fields</summary>
        </member>
        <member name="M:DryIoc.ImTools.Hasher.Combine(System.Int32,System.Int32)">
            <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        </member>
        <member name="T:DryIoc.ImTools.StackPool`1">
            Simple unbounded object pool
        </member>
        <member name="M:DryIoc.ImTools.StackPool`1.RentOrDefault">
            <summary>Give me an object</summary>
        </member>
        <member name="M:DryIoc.ImTools.StackPool`1.Return(`0)">
            <summary>Give it back</summary>
        </member>
        <member name="T:DryIoc.ImTools.KV`2">
            <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
            which is different from System value type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            In addition provides <see cref="M:DryIoc.ImTools.KV`2.Equals(System.Object)"/> and <see cref="M:DryIoc.ImTools.KV`2.GetHashCode"/> implementations.</summary>
            <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
        </member>
        <member name="F:DryIoc.ImTools.KV`2.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:DryIoc.ImTools.KV`2.Value">
            <summary>Value.</summary>
        </member>
        <member name="M:DryIoc.ImTools.KV`2.#ctor(`0,`1)">
            <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
            <param name="key">key.</param><param name="value">value.</param>
        </member>
        <member name="M:DryIoc.ImTools.KV`2.Print(System.Text.StringBuilder,System.Func{System.Text.StringBuilder,System.Object,System.Text.StringBuilder})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.KV`2.ToString">
            <summary>Creates nice string view.</summary><returns>String representation.</returns>
        </member>
        <member name="M:DryIoc.ImTools.KV`2.Equals(System.Object)">
            <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        </member>
        <member name="M:DryIoc.ImTools.KV`2.GetHashCode">
            <summary>Combines key and value hash code</summary>
        </member>
        <member name="T:DryIoc.ImTools.KV">
            <summary>Helpers for <see cref="T:DryIoc.ImTools.KV`2"/>.</summary>
        </member>
        <member name="M:DryIoc.ImTools.KV.Of``2(``0,``1)">
            <summary>Creates the key value pair.</summary>
        </member>
        <member name="M:DryIoc.ImTools.KV.WithValue``2(DryIoc.ImTools.KV{``0,``1},``1)">
            <summary>Creates the pair with the new value</summary>
        </member>
        <member name="T:DryIoc.ImTools.KeyValuePair">
            Simple helper for creation of the pair of two parts.
        </member>
        <member name="M:DryIoc.ImTools.KeyValuePair.Pair``2(``0,``1)">
            Pairs key with value.
        </member>
        <member name="T:DryIoc.ImTools.Opt`1">
            <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
        </member>
        <member name="M:DryIoc.ImTools.Opt`1.op_Implicit(`0)~DryIoc.ImTools.Opt{`0}">
            <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        </member>
        <member name="F:DryIoc.ImTools.Opt`1.Value">
            <summary>Argument value.</summary>
        </member>
        <member name="F:DryIoc.ImTools.Opt`1.HasValue">
            <summary>Indicates that value is provided.</summary>
        </member>
        <member name="M:DryIoc.ImTools.Opt`1.#ctor(`0)">
            <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        </member>
        <member name="M:DryIoc.ImTools.Opt`1.OrDefault(`0)">
            <summary>Helper to get value or default value if value is not present.</summary>
        </member>
        <member name="T:DryIoc.ImTools.GrowingList">
            <summary>Ever growing list methods</summary>
        </member>
        <member name="F:DryIoc.ImTools.GrowingList.DefaultInitialCapacity">
            <summary>Default initial capacity </summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList.PushSlot``1(``0[]@,System.Int32)">
            Push the new slot and return the ref to it
        </member>
        <member name="M:DryIoc.ImTools.GrowingList.Push``1(``0[]@,System.Int32,``0)">
            Adds the new item possibly extending the item collection
        </member>
        <member name="M:DryIoc.ImTools.GrowingList.Expand``1(``0[]@)">
            <summary>Expands the items starting with 2</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList.ResizeToArray``1(``0[],System.Int32)">
            <summary>Creates the final array out of the list, so that you cannot use after that!</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList.ToString``1(``0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.ImTools.GrowingList`1">
            <summary>Ever growing list</summary>
        </member>
        <member name="F:DryIoc.ImTools.GrowingList`1.DefaultInitialCapacity">
            <summary>Default initial capacity </summary>
        </member>
        <member name="F:DryIoc.ImTools.GrowingList`1.Items">
            <summary>The items array</summary>
        </member>
        <member name="F:DryIoc.ImTools.GrowingList`1.Count">
            <summary>The count</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList`1.#ctor(`0[],System.Int32)">
            <summary>Constructs the thing</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList`1.PushSlot">
            <summary>Push the new slot and return the ref to it</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList`1.Push(`0)">
            <summary>Adds the new item possibly extending the item collection</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList`1.Pop">
            <summary>Pops the item - just moving the counter back</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList`1.ResizeToArray">
            <summary>Creates the final array out of the list, so that you cannot use after that!</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList`1.PopItem">
            <summary>Pops the item - just moving the counter back</summary>
        </member>
        <member name="M:DryIoc.ImTools.GrowingList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.ImTools.ImList`1">
            <summary>Immutable list - simplest linked list with the Head and the Tail.</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImList`1.Empty">
            <summary>Empty list to Push to.</summary>
        </member>
        <member name="P:DryIoc.ImTools.ImList`1.IsEmpty">
            <summary>True for empty list.</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImList`1.Head">
            <summary>First value in a list.</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImList`1.Tail">
            <summary>The rest of values or Empty if list has a single value.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList`1.Push(`0)">
            <summary>Prepends new value and returns new list.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList`1.Enumerate">
            <summary>Enumerates the list.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList`1.ToString">
            <summary>String representation for debugging purposes</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImList">
            <summary>Extension methods providing basic operations on a list.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.Deconstruct``1(DryIoc.ImTools.ImList{``0},``0@,DryIoc.ImTools.ImList{``0}@,System.Boolean@)">
            Split list into (Head, Tail, IsEmpty) tuple
        </member>
        <member name="M:DryIoc.ImTools.ImList.List``1(``0[])">
            <summary>
            Constructs the reversed list from the parameter array of items
            </summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.ToImList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Constructs the list as the reversed input list
            </summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.ToImList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Constructs the list as the reversed enumerable
            </summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.List``1(``0)">
            <summary>Constructs list of one element</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.List``1(``0,DryIoc.ImTools.ImList{``0})">
            <summary>Constructs list from head and tail</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.ForEach``1(DryIoc.ImTools.ImList{``0},System.Action{``0})">
            <summary>Apples some effect action to each element</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.Fold``2(DryIoc.ImTools.ImList{``0},``1,System.Func{``0,``1,``1})">
            <summary>Fold list to a single value. The respective name for it in LINQ is Aggregate</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.Fold``2(DryIoc.ImTools.ImList{``0},``1,System.Func{``0,System.Int32,``1,``1})">
            <summary>Fold list to a single value with index of item. The respective name for it in LINQ is Aggregate.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.Reverse``1(DryIoc.ImTools.ImList{``0})">
            <summary>Returns new list in reverse order.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.Map``2(DryIoc.ImTools.ImList{``0},System.Func{``0,``1})">
            <summary>Maps the items from the first list to the result list.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.Map``2(DryIoc.ImTools.ImList{``0},System.Func{``0,System.Int32,``1})">
            <summary>Maps with index</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImList.ToArray``1(DryIoc.ImTools.ImList{``0})">
            <summary>Copies list to array.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImZipper`1">
            Zipper is an immutable persistent data structure, to represent collection with single focused (selected, active) element.
            Consist of REVERSED `Left` immutable list, `Focus` element, and the `Right` immutable list. That's why a Zipper name,
            where left and right part are joined / zipped in focus item.
        </member>
        <member name="F:DryIoc.ImTools.ImZipper`1.Empty">
            Empty singleton instance to start building your zipper
        </member>
        <member name="P:DryIoc.ImTools.ImZipper`1.IsEmpty">
            True is zipper does not contain items
        </member>
        <member name="F:DryIoc.ImTools.ImZipper`1.Index">
            Index of Focus item, from `0` to `Count-1`
        </member>
        <member name="F:DryIoc.ImTools.ImZipper`1.Count">
            Number of items
        </member>
        <member name="F:DryIoc.ImTools.ImZipper`1.Left">
            Left REVERSED list, so the Head of the list is just prior the Focus item 
        </member>
        <member name="F:DryIoc.ImTools.ImZipper`1.Right">
            Right list, where Head is just after the Focus item
        </member>
        <member name="F:DryIoc.ImTools.ImZipper`1.Focus">
            Single focus item
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.Append(`0)">
            Sets a new focus and pushes the old focus to the Left list. 
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.PushLeft(`0)">
            Sets a new focus and pushes the old focus to the Left list.
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.Insert(`0)">
            Sets a new focus and pushes the old focus to the right list. 
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.PushRight(`0)">
            Sets a new focus and pushes the old focus to the right list. 
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.PopLeft">
            Removes a focus, filling the hole with the item from the left list, or from the right if the left is empty
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.PopRight">
            Removes a focus, filling the hole with the item from the right list, or from the left if the right is empty
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.ShiftLeft">
            Shifts focus one element to the left (decrementing its Index).
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.ShiftRight">
            Shifts focus one element to the right (incrementing its Index).
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.WithFocus(`0)">
            Sets a new focus and returns a new zipper with the left and right lists unchanged
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.Map``1(System.Func{`0,``0})">
            Maps over the zipper items producing a new zipper
        </member>
        <member name="M:DryIoc.ImTools.ImZipper`1.Map``1(System.Func{`0,System.Int32,``0})">
            Maps over the zipper items with item index, producing a new zipper
        </member>
        <member name="T:DryIoc.ImTools.ImZipper">
            Other ImZipper methods
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.Zip``1(``0[])">
            Appends array items to zipper
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.ToArray``1(DryIoc.ImTools.ImZipper{``0})">
            Converts to array.
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.ShiftTo``1(DryIoc.ImTools.ImZipper{``0},System.Int32)">
            Shifts focus to a specified index, e.g. a random access
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.Update``1(DryIoc.ImTools.ImZipper{``0},System.Func{``0,``0})">
            Updates a focus element if it is present, otherwise does nothing.
            If the focus item is the equal one, then returns the same zipper back.
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.UpdateAt``1(DryIoc.ImTools.ImZipper{``0},System.Int32,System.Func{``0,``0})">
            Update the item at random index, by shifting and updating it
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.RemoveAt``1(DryIoc.ImTools.ImZipper{``0},System.Int32)">
            Update the item at random index, by shifting and updating it
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.Fold``2(DryIoc.ImTools.ImZipper{``0},``1,System.Func{``0,``1,``1})">
            Folds zipper to a single value
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.Fold``2(DryIoc.ImTools.ImZipper{``0},``1,System.Func{``0,System.Int32,``1,``1})">
            Folds zipper to a single value by using an item index
        </member>
        <member name="M:DryIoc.ImTools.ImZipper.ForEach``1(DryIoc.ImTools.ImZipper{``0},System.Action{``0})">
            <summary>Apply some effect action on each element</summary>
        </member>
        <member name="T:DryIoc.ImTools.Update`1">
            Given the old value should and the new value should return result updated value.
        </member>
        <member name="T:DryIoc.ImTools.Update`2">
            Update handler including the key
        </member>
        <member name="T:DryIoc.ImTools.ImHashMapEntry`2">
            <summary>Entry containing the Key and Value in addition to the Hash</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImHashMapEntry`2.Key">
            <summary>The key</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImHashMapEntry`2.Value">
            <summary>The value. Maybe modified if you need the Ref{Value} semantics. 
            You may add the entry with the default Value to the map, and calculate and set it later (e.g. using the CAS).</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMapEntry`2.#ctor(System.Int32,`0)">
            <summary>Constructs the entry with the key and value</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMapEntry`2.#ctor(System.Int32,`0,`1)">
            <summary>Constructs the entry with the key and value</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMapEntry`2.Count">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.ImHashMapEntry`2.GetEntryOrNull(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.ImHashMapEntry`2.Update(DryIoc.ImTools.ImHashMapEntry{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.ImHashMapEntry`2.UpdateOrKeep``1(``0,DryIoc.ImTools.ImHashMapEntry{`0,`1},DryIoc.ImTools.ImHashMap{`0,`1}.UpdaterOrKeeper{``0})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.ImHashMapEntry`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.ImTools.HashConflictingEntry`2">
            <summary>The composite containing the list of entries with the same conflicting Hash.</summary>
        </member>
        <member name="M:DryIoc.ImTools.HashConflictingEntry`2.GetEntryOrNull(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.HashConflictingEntry`2.Update(DryIoc.ImTools.ImHashMapEntry{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.HashConflictingEntry`2.UpdateOrKeep``1(``0,DryIoc.ImTools.ImHashMapEntry{`0,`1},DryIoc.ImTools.ImHashMap{`0,`1}.UpdaterOrKeeper{``0})">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2">
            <summary>The base and the holder class for the map tree leafs and branches, also defines the Empty tree.
            The map implementation is based on the "modified" 2-3 tree.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.#ctor">
            <summary>Hide the base constructor to prevent the multiple Empty trees creation</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImHashMap`2.Empty">
            <summary>Empty map to start with. Exists as a single instance.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.ToString">
            <summary>Prints the map tree in JSON-ish format in release mode and enumerates the keys in DEBUG.</summary>
        </member>
        <member name="P:DryIoc.ImTools.ImHashMap`2.IsEmpty">
            <summary>Indicates that the map is empty</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.Count">
            <summary>The count of entries in the map</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.GetEntryOrNull(System.Int32)">
            <summary>Lookup for the entry by hash. If nothing the method returns `null`</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.AddOrGetEntry(System.Int32,DryIoc.ImTools.ImHashMap{`0,`1}.Entry)">
            <summary>Returns the found entry with the same hash or the new map with added new entry.
            Note that the empty map will return the entry the same as if the entry was found - so the consumer should check for the empty map.
            Note that the method cannot return the `null` - when the existing entry is not found it will always be the new map with the added entry.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.ReplaceEntry(System.Int32,DryIoc.ImTools.ImHashMap{`0,`1}.Entry,DryIoc.ImTools.ImHashMap{`0,`1}.Entry)">
            <summary>Returns the new map with old entry replaced by the new entry. Note that the old entry should be present.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.RemoveEntry(DryIoc.ImTools.ImHashMap{`0,`1}.Entry)">
            <summary>Removes the certainly present old entry and returns the new map without it.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.UpdaterOrKeeper`1">
            <summary>The delegate is supposed to return entry different from the oldEntry to update, and return the oldEntry to keep it.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Entry">
            <summary>The base map entry for holding the hash and payload</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImHashMap`2.Entry.Hash">
            <summary>The Hash</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.Entry.#ctor(System.Int32)">
            <summary>Constructs the entry with the hash</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.Entry.GetEntryOrNull(System.Int32,`0)">
            <summary>Lookup for the entry by Hash and Key</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.Entry.Update(DryIoc.ImTools.ImHashMapEntry{`0,`1})">
            <summary>Updating the entry with the new one</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.Entry.UpdateOrKeep``1(``0,DryIoc.ImTools.ImHashMapEntry{`0,`1},DryIoc.ImTools.ImHashMap{`0,`1}.UpdaterOrKeeper{``0})">
            <summary>Updating the entry with the new one using the `update` method</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap`2.Entry.AddOrGetEntry(System.Int32,DryIoc.ImTools.ImHashMap{`0,`1}.Entry)">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Leaf2">
            <summary>Leaf with 2 hash-ordered entries. Important: the both or either of entries may be null for the removed entries</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Leaf2Plus1">
            <summary>The leaf containing the Leaf2 plus the newest added entry.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Leaf2Plus1Plus1">
            <summary>Leaf with the Leaf2 plus added entry, plus added entry</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Leaf5">
            <summary>Leaf with 5 hash-ordered entries</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Leaf5Plus1">
            <summary>Leaf with 5 existing ordered entries plus 1 newly added entry.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Leaf5Plus1Plus1">
            <summary>Leaf with 5 existing ordered entries plus 1 newly added, plus 1 newly added.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Branch2">
            <summary>Branch of 2 leafs or branches with entry in the middle</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap`2.Branch3">
            <summary>Branch of 3 with 2 nodes in between</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMapEntry`1">
            <summary>Entry containing the Value in addition to the Hash</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImMapEntry`1.Hash">
            <summary>The hash.</summary>
        </member>
        <member name="P:DryIoc.ImTools.ImMapEntry`1.Key">
            <summary>The Key is actually the Hash for this entry and the vice versa.</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImMapEntry`1.Value">
            <summary>The value. Maybe modified if you need the Ref{Value} semantics. 
            You may add the entry with the default Value to the map, and calculate and set it later (e.g. using the CAS).</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMapEntry`1.#ctor(System.Int32)">
            <summary>Constructs the entry with the default value</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMapEntry`1.#ctor(System.Int32,`0)">
            <summary>Constructs the entry with the value</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMapEntry`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ImTools.ImMapEntry`1.Count">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1">
            <summary>The base and the holder class for the map tree leafs and branches, also defines the Empty tree.
            The map implementation is based on the "modified" 2-3 tree.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap`1.#ctor">
            <summary>Hide the base constructor to prevent the multiple Empty trees creation</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImMap`1.Empty">
            <summary>Empty map to start with. Exists as a single instance.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap`1.ToString">
            <summary>Prints the map tree in JSON-ish format in release mode and enumerates the keys in DEBUG.</summary>
        </member>
        <member name="P:DryIoc.ImTools.ImMap`1.IsEmpty">
            <summary>Indicates that the map is empty</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap`1.Count">
            <summary>The count of entries in the map</summary>
        </member>
        <member name="P:DryIoc.ImTools.ImMap`1.IsBranch">
            <summary>`true` if node is branch</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap`1.GetEntryOrNull(System.Int32)">
            <summary>Lookup for the entry by hash. 
            You need to check the returned entry type because it maybe the `HashConflictKeyValuesEntry` which contain multiple key value entries for the same hash. For the `int` key you may be sure that the `ImHashMapEntry{V}` is always returned.
            If nothing the method returns `null`</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap`1.AddOrGetEntry(System.Int32,DryIoc.ImTools.ImMapEntry{`0})">
            <summary>Returns the found entry with the same hash or the new map with added new entry.
            Note that the empty map will return the entry the same as if the entry was found - so the consumer should check for the empty map.
            Note that the method cannot return the `null` - when the existing entry is not found it will always be the new map with the added entry.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap`1.ReplaceEntry(System.Int32,DryIoc.ImTools.ImMapEntry{`0},DryIoc.ImTools.ImMapEntry{`0})">
            <summary>Returns the new map with old entry replaced by the new entry. 
            Note that the old entry should be present.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap`1.RemoveEntry(DryIoc.ImTools.ImMapEntry{`0})">
            <summary>Removes the certainly present old entry and returns the new map without it.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Leaf2">
            <summary>Leaf with 2 hash-ordered entries. Important: the both or either of entries may be null for the removed entries</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Leaf2Plus1">
            <summary>The leaf containing the Leaf2 plus the newest added entry.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Leaf2Plus1Plus1">
            <summary>Leaf with the Leaf2 plus added entry, plus added entry</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Leaf5">
            <summary>Leaf with 5 hash-ordered entries</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Leaf5Plus1">
            <summary>Leaf with 5 existing ordered entries plus 1 newly added entry.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Leaf5Plus1Plus1">
            <summary>Leaf with 5 existing ordered entries plus 1 newly added, plus 1 newly added.</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Branch2">
            <summary>The 2 branches with the node in between</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Branch2Plus1">
            <summary>The 2 branches with the node in between</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap`1.Branch3">
            <summary>The 3 branches with the 2 nodes in between</summary>
        </member>
        <member name="T:DryIoc.ImTools.MapParentStack">
            <summary>Helper stack wrapper for the array</summary>
        </member>
        <member name="M:DryIoc.ImTools.MapParentStack.#ctor">
            <summary>Creates the list of the `DefaultInitialCapacity`</summary>
        </member>
        <member name="M:DryIoc.ImTools.MapParentStack.Put(System.Object,System.Int32)">
            <summary>Pushes the item</summary>
        </member>
        <member name="M:DryIoc.ImTools.MapParentStack.Get(System.Int32)">
            <summary>Gets the item by index</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMapParentStack`1">
            <summary>Helper stack wrapper for the array</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMapParentStack`1.Entry">
            <summary>Entry in a stack</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImMapParentStack`1.Entry.NextEntry">
            <summary>The next entry to traverse</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImMapParentStack`1.Entry.NextBranch">
            <summary>The next branch to traverse</summary>
        </member>
        <member name="F:DryIoc.ImTools.ImMapParentStack`1.Items">
            <summary>The items</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMapParentStack`1.#ctor(System.Int32)">
            <summary>Creates the list of the `DefaultInitialCapacity`</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMapParentStack`1.Put(System.Int32,DryIoc.ImTools.ImMapEntry{`0},DryIoc.ImTools.ImMap{`0})">
            <summary>Pushes the item</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImHashMap">
            <summary>The map methods</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Entry``2(``0,``1)">
            <summary>Creates the entry to help with inference</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Entry``2(System.Int32,``0,``1)">
            <summary>Creates the entry to help with inference</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.WithConflicting``2(DryIoc.ImTools.ImHashMapEntry{``0,``1},DryIoc.ImTools.ImHashMapEntry{``0,``1})">
            <summary>Creates the conflicting entry out of two entries</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.SetValue``2(DryIoc.ImTools.ImHashMapEntry{``0,``1},``1)">
            <summary>Sets the value and returns the entry</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Enumerate``2(DryIoc.ImTools.ImHashMap{``0,``1},DryIoc.ImTools.MapParentStack)">
            <summary>Enumerates all the map entries in the hash order.
            The `parents` parameter allow sto reuse the stack memory used for traversal between multiple enumerates.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent `Enumerate` calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.ForEach``3(DryIoc.ImTools.ImHashMap{``0,``1},``2,System.Action{DryIoc.ImTools.ImHashMapEntry{``0,``1},System.Int32,``2},DryIoc.ImTools.MapParentStack)">
            <summary>
            Depth-first in-order of hash traversal as described in http://en.wikipedia.org/wiki/Tree_traversal.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.ForEach``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Action{DryIoc.ImTools.ImHashMapEntry{``0,``1},System.Int32},DryIoc.ImTools.MapParentStack)">
            <summary>Do something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Fold``3(DryIoc.ImTools.ImHashMap{``0,``1},``2,System.Func{DryIoc.ImTools.ImHashMapEntry{``0,``1},System.Int32,``2,``2},DryIoc.ImTools.MapParentStack)">
            <summary>Collect something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.ToArray``3(DryIoc.ImTools.ImHashMap{``0,``1},System.Func{DryIoc.ImTools.ImHashMapEntry{``0,``1},``2})">
            <summary>Converts map to an array with the minimum allocations</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.ToArray``2(DryIoc.ImTools.ImHashMap{``0,``1})">
            <summary>Converts map to an array with the minimum allocations</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.ToDictionary``2(DryIoc.ImTools.ImHashMap{``0,``1})">
            <summary>Converts the map to the dictionary</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.GetEntryOrDefault``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Get the key-value entry if the hash and key is in the map or the default `null` value otherwise.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.GetEntryOrDefaultByReferenceEquals``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Get the key-value entry if the hash and key is in the map or the default `null` value otherwise.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.GetEntryOrDefault``2(DryIoc.ImTools.ImHashMap{``0,``1},``0)">
            <summary>Get the key value entry if the key is in the map or the default `null` value otherwise.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Contains``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Returns <see langword="true"/> if map contains the hash and key, otherwise returns <see langword="false"/></summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Contains``2(DryIoc.ImTools.ImHashMap{``0,``1},``0)">
            <summary>Returns <see langword="true"/> if map contains the key, otherwise returns <see langword="false"/></summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.GetSurePresentEntry``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.
            You can use the method after the Add and Update methods on the same map instance - because the map is immutable it is for sure contains added or updated entry.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.GetValueOrDefault``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality, 
            returns the default `V` if hash, key are not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.GetValueOrDefault``2(DryIoc.ImTools.ImHashMap{``0,``1},``0)">
            <summary>Lookup for the value by key using its hash and checking the key with the `object.Equals` for equality, 
            returns the default `V` if hash, key are not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.GetValueOrDefaultByReferenceEquals``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,
             returns found value or the default value if not found</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.TryFind``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0,``1@)">
            <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality,
            returns the `true` and the found value or the `false` otherwise</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.TryFindByReferenceEquals``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0,``1@)">
            <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals`, 
            returns the `true` and the found value or the `false` otherwise</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.TryFind``2(DryIoc.ImTools.ImHashMap{``0,``1},``0,``1@)">
            <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality,
            returns the `true` and the found value or the `false` otherwise</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrGetEntry``2(DryIoc.ImTools.ImHashMap{``0,``1},DryIoc.ImTools.ImHashMapEntry{``0,``1})">
            <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, 
            so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrUpdate``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0,``1)">
            <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrUpdateEntry``2(DryIoc.ImTools.ImHashMap{``0,``1},DryIoc.ImTools.ImHashMapEntry{``0,``1})">
            <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrUpdate``2(DryIoc.ImTools.ImHashMap{``0,``1},``0,``1)">
            <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrUpdate``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0,``1,DryIoc.ImTools.Update{``0,``1})">
            <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.UpdateEntry``2(DryIoc.ImTools.ImHashMap{``0,``1}.Entry,DryIoc.ImTools.ImHashMapEntry{``0,``1},DryIoc.ImTools.Update{``0,``1})">
            <summary>Updates the possibly the conflicted entry with the new key and value entry using the provided update function.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrUpdate``2(DryIoc.ImTools.ImHashMap{``0,``1},``0,``1,DryIoc.ImTools.Update{``0,``1})">
            <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Update``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0,``1)">
            <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Update``2(DryIoc.ImTools.ImHashMap{``0,``1},``0,``1)">
            <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.UpdateToDefault``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.UpdateToDefault``2(DryIoc.ImTools.ImHashMap{``0,``1},``0)">
            <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Update``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0,``1,DryIoc.ImTools.Update{``0,``1})">
            <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.
            If `update` returns the same map if the updated result is the same</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Update``2(DryIoc.ImTools.ImHashMap{``0,``1},``0,``1,DryIoc.ImTools.Update{``0,``1})">
            <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.
            If `update` returns the same map if the updated result is the same</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrKeepEntry``2(DryIoc.ImTools.ImHashMap{``0,``1},DryIoc.ImTools.ImHashMapEntry{``0,``1})">
            <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrKeep``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0,``1)">
            <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.AddOrKeep``2(DryIoc.ImTools.ImHashMap{``0,``1},``0,``1)">
            <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Remove``2(DryIoc.ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImHashMap.Remove``2(DryIoc.ImTools.ImHashMap{``0,``1},``0)">
            <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap">
            <summary>The map methods</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.Entry``1(System.Int32,``0)">
            <summary>Creates the entry to help with inference</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap.ImMapEnumerable`1">
            <summary>Non-allocating enumerator</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ImMapEnumerable`1.#ctor(DryIoc.ImTools.ImMap{`0})">
            <summary>Constructor</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ImMapEnumerable`1.GetEnumerator">
            <summary>Returns non-allocating enumerator</summary>
        </member>
        <member name="T:DryIoc.ImTools.ImMap.ImMapEnumerator`1">
            <summary>Enumerator on stack, without allocation</summary>
        </member>
        <member name="P:DryIoc.ImTools.ImMap.ImMapEnumerator`1.Current">
            <summary></summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ImMapEnumerator`1.MoveNext">
            <summary></summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.Enumerate``1(DryIoc.ImTools.ImMap{``0})">
            <summary>Enumerates all the map entries in the hash order.
            `parents` parameter allows to reuse the stack memory used for traversal between multiple enumerates.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent `Enumerate` calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ForEach``2(DryIoc.ImTools.ImMap{``0},``1,System.Action{DryIoc.ImTools.ImMapEntry{``0},System.Int32,``1},DryIoc.ImTools.MapParentStack)">
            <summary>Depth-first in-order of hash traversal as described in http://en.wikipedia.org/wiki/Tree_traversal.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ForEach``1(DryIoc.ImTools.ImMap{``0},System.Action{DryIoc.ImTools.ImMapEntry{``0},System.Int32},DryIoc.ImTools.MapParentStack)">
            <summary>Do something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.Fold``2(DryIoc.ImTools.ImMap{``0},``1,System.Func{DryIoc.ImTools.ImMapEntry{``0},System.Int32,``1,``1},DryIoc.ImTools.MapParentStack)">
            <summary>Collect something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ToArray``2(DryIoc.ImTools.ImMap{``0},System.Func{DryIoc.ImTools.ImMapEntry{``0},``1})">
            <summary>Converts the map to an array with the minimum allocations</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ToArray``1(DryIoc.ImTools.ImMap{``0})">
            <summary>Converts the map to an array with the minimum allocations</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.ToDictionary``1(DryIoc.ImTools.ImMap{``0})">
            <summary>Converts the map to the dictionary</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.GetSurePresentEntry``1(DryIoc.ImTools.ImMap{``0},System.Int32)">
            <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.
            You can use the method after the Add and Update methods on the same map instance - because the map is immutable it is for sure contains added or updated entry.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.GetEntryOrDefault``1(DryIoc.ImTools.ImMap{``0},System.Int32)">
            <summary>Lookup for the entry by hash, returns the found entry or `null`.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.GetValueOrDefault``1(DryIoc.ImTools.ImMap{``0},System.Int32)">
            <summary>Lookup for the value by hash, returns the default `V` if hash is not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.TryFind``1(DryIoc.ImTools.ImMap{``0},System.Int32,``0@)">
            <summary>Lookup for the value by its hash, returns the `true` and the found value or the `false` otherwise</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.AddOrGetEntry``1(DryIoc.ImTools.ImMap{``0},DryIoc.ImTools.ImMapEntry{``0})">
            <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, 
            so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.AddOrUpdateEntry``1(DryIoc.ImTools.ImMap{``0},DryIoc.ImTools.ImMapEntry{``0})">
            <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.AddOrUpdate``1(DryIoc.ImTools.ImMap{``0},System.Int32,``0)">
            <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.AddOrUpdate``1(DryIoc.ImTools.ImMap{``0},System.Int32,``0,DryIoc.ImTools.Update{System.Int32,``0})">
            <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.Update``1(DryIoc.ImTools.ImMap{``0},System.Int32,``0)">
            <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.UpdateToDefault``1(DryIoc.ImTools.ImMap{``0},System.Int32)">
            <summary>Updates the map with the default value if the hash is found otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.AddOrKeepEntry``1(DryIoc.ImTools.ImMap{``0},DryIoc.ImTools.ImMapEntry{``0})">
            <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.AddOrKeep``1(DryIoc.ImTools.ImMap{``0},System.Int32,``0)">
            <summary>Produces the new map with the new entry or keeps the existing map if the entry with the hash is already present</summary>
        </member>
        <member name="M:DryIoc.ImTools.ImMap.Remove``1(DryIoc.ImTools.ImMap{``0},System.Int32)">
            <summary>Returns the new map without the specified hash (if found) or returns the same map otherwise</summary>
        </member>
        <member name="T:DryIoc.ImTools.PartitionedHashMap">
            <summary>
            The fixed array of maps (partitions) where the key first (lower) bits are used to locate the partion to lookup into.
            Note: The partition array is NOT immutable and operates by swapping the updated partition with the new one.
            The number of partitions may be specified by user or you can use the default number 16.
            The default number 16 was selected to be not so big to pay for the few items and not so small to diminish the use of partitions.
            </summary>
        </member>
        <member name="F:DryIoc.ImTools.PartitionedHashMap.PARTITION_COUNT_POWER_OF_TWO">
            <summary>The default number of partitions</summary>
        </member>
        <member name="F:DryIoc.ImTools.PartitionedHashMap.PARTITION_HASH_MASK">
            <summary>The default mask to partition the key</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.CreateEmpty``2(System.Int32)">
            <summary>Creates the new collection with the empty partions</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.GetValueOrDefault``2(DryIoc.ImTools.ImHashMap{``0,``1}[],System.Int32,``0,System.Int32)">
            <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality, 
            returns the default `V` if hash, key are not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.GetValueOrDefaultByReferenceEquals``2(DryIoc.ImTools.ImHashMap{``0,``1}[],System.Int32,``0,System.Int32)">
            <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,
             returns found value or the default value if not found</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.GetValueOrDefault``2(DryIoc.ImTools.ImHashMap{``0,``1}[],``0,System.Int32)">
            <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality, 
            returns the default `V` if hash, key are not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.TryFind``2(DryIoc.ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1@,System.Int32)">
            <summary>Lookup for the value by the key using the hash code and checking the key with the `object.Equals` for equality,
            returns the `true` and the found value or the `false`</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.TryFind``2(DryIoc.ImTools.ImHashMap{``0,``1}[],``0,``1@,System.Int32)">
            <summary>Lookup for the value by the key using its hash code and checking the key with the `object.Equals` for equality,
            returns the `true` and the found value or the `false`</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.TryFindByReferenceEquals``2(DryIoc.ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1@,System.Int32)">
            <summary>Lookup for the value by the key using the hash code and checking the key with the `object.ReferenceEquals` for equality,
            returns the `true` and the found value or the `false`</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.GetValueOrDefaultByReferenceEquals``2(DryIoc.ImTools.ImHashMap{``0,``1}[],``0,System.Int32)">
            <summary>Lookup for the value by the key using its hash and checking the key with the `object.ReferenceEquals` for equality, 
            returns the default `V` if hash, key are not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.AddOrUpdate``2(DryIoc.ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1,System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.AddOrUpdate``2(DryIoc.ImTools.ImHashMap{``0,``1}[],``0,``1,System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.AddOrUpdate``2(DryIoc.ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1,DryIoc.ImTools.Update{``0,``1},System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.AddOrKeep``2(DryIoc.ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1,System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.AddOrKeep``2(DryIoc.ImTools.ImHashMap{``0,``1}[],``0,``1,System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.Enumerate``2(DryIoc.ImTools.ImHashMap{``0,``1}[],DryIoc.ImTools.MapParentStack)">
            <summary>Do something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedHashMap.ForEach``3(DryIoc.ImTools.ImHashMap{``0,``1}[],``2,System.Action{DryIoc.ImTools.ImHashMapEntry{``0,``1},System.Int32,``2},DryIoc.ImTools.MapParentStack)">
            <summary>Do something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="T:DryIoc.ImTools.PartitionedMap">
            <summary>
            The fixed array of maps (partitions) where the key first (lower) bits are used to locate the partion to lookup into.
            Note: The partition array is NOT immutable and operates by swapping the updated partition with the new one.
            The number of partitions may be specified by user or you can use the default number 16.
            The default number 16 was selected to be not so big to pay for the few items and not so small to diminish the use of partitions.
            </summary>
        </member>
        <member name="F:DryIoc.ImTools.PartitionedMap.PARTITION_COUNT_POWER_OF_TWO">
            <summary>The default number of partitions</summary>
        </member>
        <member name="F:DryIoc.ImTools.PartitionedMap.PARTITION_HASH_MASK">
            <summary>The default mask to partition the key</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.CreateEmpty``1(System.Int32)">
            <summary>Creates the new collection with the empty partions</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.GetValueOrDefault``1(DryIoc.ImTools.ImMap{``0}[],System.Int32,System.Int32)">
            <summary>Lookup for the value by the key using its hash, returns the default `V` if hash is not found.</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.TryFind``1(DryIoc.ImTools.ImMap{``0}[],System.Int32,``0@,System.Int32)">
            <summary>Lookup for the value by the key using the hash, returns the `true` and the found value or the `false`</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.AddOrUpdate``1(DryIoc.ImTools.ImMap{``0}[],System.Int32,``0,System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.AddOrUpdate``1(DryIoc.ImTools.ImMap{``0}[],System.Int32,``0,DryIoc.ImTools.Update{System.Int32,``0},System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.AddOrKeep``1(DryIoc.ImTools.ImMap{``0}[],System.Int32,``0,System.Int32)">
            <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.Update``1(DryIoc.ImTools.ImMap{``0}[],System.Int32,``0,System.Int32)">
            <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.Enumerate``1(DryIoc.ImTools.ImMap{``0}[])">
            <summary>Do something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
        <member name="M:DryIoc.ImTools.PartitionedMap.ForEach``2(DryIoc.ImTools.ImMap{``0}[],``1,System.Action{DryIoc.ImTools.ImMapEntry{``0},System.Int32,``1},DryIoc.ImTools.MapParentStack)">
            <summary>Do something for each entry.
            The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
            So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        </member>
    </members>
</doc>
